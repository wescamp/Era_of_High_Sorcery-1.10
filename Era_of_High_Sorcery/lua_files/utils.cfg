this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- utils.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local select = select
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

-- Iterating over varargs, handling nil properly
--   (cf http://lua-users.org/wiki/VarargTheSecondClassCitizen , issue #8)
EoHS.vararg = function(...)
  local t, i, l = {...}, 0, select("#", ...)
  return function()
    i = i + 1
    if i > l then return end
    return i, t[i]
  end
end

EoHS.err = function(input)
  wesnoth.fire("wml_message", { logger="err", message=(_"EoHS error: ")..((type(input) == "string") and input or EoHS.inspect(input)).."\n"..debug.traceback() })
end
EoHS.debug = function(...)
  wesnoth.fire("wml_message", { logger="err", message=(_"EoHS debug: ")..EoHS.inspect({...}) })
  return ...
end
EoHS.assert = function(condition, input)
  if not condition then EoHS.err(input) end
end

EoHS.timestamp = function()
  if wesnoth.get_time_stamp then return wesnoth.get_time_stamp() end
  wesnoth.fire("set_variable", {name="EoHS.LUA_TEMP", time="stamp"})
  local result = EoHS.get_variable("LUA_TEMP")
  EoHS.set_variable("LUA_TEMP")
  return result
end

EoHS.hosted_version = EoHS.macros.EOHS_VERSION_STRING
EoHS.local_version = wesnoth.unit_types.EoHS_local_version_checker and wesnoth.unit_types.EoHS_local_version_checker.__cfg.name

local pack = function(...) return {...} end

EoHS.get_variable = function(varname)
  return wesnoth.get_variable("EoHS."..varname)
end

EoHS.set_variable = function(varname, value)
  wesnoth.set_variable("EoHS."..varname, value)
end

EoHS.init_side_variables = function(side)
  EoHS.set_variable("side["..(side-1).."]", {})
end
EoHS.get_side_variables = function(side)
  return EoHS.get_variable("side["..(side-1).."]")
end
EoHS.get_side_variable = function(side, varname)
  return EoHS.get_variable("side["..(side-1).."]."..varname)
end
EoHS.set_side_variable = function(side, varname, value)
  EoHS.set_variable("side["..(side-1).."]."..varname, value)
end
-- Note: circles of protection rely on this implementation
EoHS.get_scenario_variable = function(varname)
  return EoHS.get_variable("scenario_vars."..varname)
end
EoHS.set_scenario_variable = function(varname, value)
  EoHS.set_variable("scenario_vars."..varname, value)
end
EoHS.get_hex_variables = function(x, y)
  return EoHS.get_scenario_variable(x.."_"..y)
end
EoHS.get_hex_variable = function(x, y, varname)
  -- Hack - avoid getting a warning if it doesn't exist
  local vars = EoHS.get_hex_variables(x, y)
  if vars then return vars[varname] or EoHS.get_subtag_attribute(vars, varname) end
end
EoHS.set_hex_variable = function(x, y, varname, value)
  EoHS.set_scenario_variable(x.."_"..y.."."..varname, value)
end

EoHS.disunified = function(func)
  local result
  local old_unison = EoHS.context.unison
  local old_sync = EoHS.context.synchronized
  EoHS.context.unison = false
  EoHS.context.synchronized = false
  if old_unison then EoHS.context.disunified_unit_tables = {} end
  result = pack(func())
  if old_unison then EoHS.context.disunified_unit_tables = nil end
  EoHS.context.unison = old_unison
  EoHS.context.synchronized = old_sync
  return unpack(result)
end

EoHS.begin_event = function(unison, synchronized, force_empty_stack, for_fire_event)
  --EoHS.err(wesnoth.current.event_context.name)
  if force_empty_stack then
    if EoHS.event_stack or EoHS.context then
      EoHS.debug("EoHS.begin_event notices that there was probably an error earlier; if there *wasn't* an error earlier, then *this* is an error")
    end
    EoHS.event_stack = nil
    EoHS.context = nil
  end
  EoHS.assert(synchronized ~= nil, "EoHS.begin_event without enough arguments")
  EoHS.assert(not EoHS.context, "EoHS.begin_event used in an existing context")
  if not EoHS.event_stack then
    EoHS.units_to_advance = {} -- Special: We always want to advance units at the end of the event stack, not at the end of each sub-event.
  end
  if not for_fire_event then
    EoHS.event_stack = {parent=EoHS.event_stack}
  end
  EoHS.context = {in_event = true, unison = unison, synchronized = synchronized }
  if unison then
    EoHS.context.unison_unit_tables = {}
    EoHS.context.unison_wunits = {}
    EoHS.context.units_to_put = {}
  end
end
local advancing_units_currently
EoHS.units_may_advance_now = function()
  -- This may invoke another nested event, which calls EoHS.end_event before doing anything, and EoHS.begin_event after.
  -- So we put it at the beginning of EoHS.end_event, so that *that* EoHS.end_event ends the second "event" properly.
  -- The nested event could theoretically add more units to EoHS.context.units_to_advance; this (hopefully) handles that properly.
  -- We do, however, need a guard against calling the same process again in the sub-events.
  if EoHS.units_to_advance and not advancing_units_currently then
    advancing_units_currently = true
    for i,xy in ipairs(EoHS.units_to_advance) do
      EoHS.units_to_advance[xy.x..","..xy.y] = nil -- so that sub-events can re-add this unit
      local unit = EoHS.get_unit(xy.x,xy.y)
      if unit and (unit.experience >= unit.max_experience) then
        EoHS.game_action_simulations.advance_unit_on_map(xy.x, xy.y, EoHS.game_action_simulations.choose_advancement(unit), true, true)
      end
    end
    EoHS.units_to_advance = {}
    advancing_units_currently = nil
  end
end
EoHS.end_event = function(for_fire_event)
  EoHS.assert(EoHS.context.in_event, "EoHS.end_event used not in an event")
  if EoHS.context.unison then
    if (not for_fire_event) and (not EoHS.event_stack.parent) then
      EoHS.units_may_advance_now()
      EoHS.units_to_advance = nil
    end
    for i,unit in ipairs(EoHS.context.units_to_put) do
      if EoHS.context.units_to_put[unit] then
        wesnoth.put_unit(unit)
        wesnoth.fire("capture_village",{x=unit.x,y=unit.y,side=unit.side})
      end
    end
  end
  EoHS.context = nil
  EoHS.clear_temporary_caches()
  if not for_fire_event then EoHS.event_stack = EoHS.event_stack.parent end
end
EoHS.fire_event = function(...)
  -- Other scenarios' events can make arbitrary changes, so don't preserve any event context.
  EoHS.assert(EoHS.context.in_event, "EoHS.fire_event used not in an event")
  local old_sync = EoHS.context.synchronized
  local old_unison = EoHS.context.unison
  EoHS.end_event(true)
  wesnoth.fire_event(...)
  EoHS.begin_event(old_unison, old_sync, false, true)
end

local random_desynced = false
EoHS.random = function(randstring)
  EoHS.assert(EoHS.context.unison, "EoHS.random used in an disunified context")
  wesnoth.fire("set_variable", { name="EoHS.LUA_TEMP", rand=randstring })
  local result = wesnoth.get_variable("EoHS.LUA_TEMP")
  wesnoth.set_variable("EoHS.LUA_TEMP")
  if EoHS.get_variable("on_a_side_turn") and EoHS.context.synchronized then
    local confirm = EoHS.synchronize_choice(function() return {r=result} end).r
    if confirm ~= result then
      if not random_desynced then
        random_desynced = true
        EoHS.err("EoHS.random has gotten desynchronized, falling back to EoHS.synchronize_choice")
      end
      result = confirm
    end
  end
  return result
end
EoHS.create_wunit = function(unit)
  if not EoHS.context.synchronized then
    unit.random_traits = false
    unit.random_gender = false
    unit.generate_name = false
  end
  return wesnoth.create_unit(unit)
end

EoHS.synchronize_choice = function(human_func, ai_func)
  if not EoHS.context.synchronized then EoHS.err("EoHS.synchronize_choice used in an unsynchronized context") end
  local result
  -- wesnoth.synchronize_choice is overly lenient about invalid wml tables, so we check them ourselves.
  -- TODO: maybe the EoHS.check_wml_table is slow enough that it should be removed.
  EoHS.disunified(function() result = wesnoth.synchronize_choice(
    function() return { { "result", EoHS.check_wml_table(human_func()) } } end,
    function() return { { "result", EoHS.check_wml_table((ai_func or human_func)()) } } end)
  end)
  if result == nil then EoHS.err("EoHS.synchronize_choice used in an invalid situation") end
  if not result[1] then return nil end
  return result[1][2]
end

EoHS.do_only_on_client_controlling_side = function(side, local_func)
  return EoHS.disunified(function()
    if (wesnoth.sides[side].controller ~= "network") and (wesnoth.sides[side].controller ~= "network_ai") then
      return local_func()
    end
  end)
end
EoHS.do_only_on_client_controlling_human_side = function(side, human_func)
  return EoHS.disunified(function()
    if wesnoth.sides[side].controller == "human" then
      return human_func()
    end
  end)
end

EoHS.substitute = function(string, values)
  local old_values = {}
  local force_nil = {}
  for k,v in pairs(values) do
    local old_v = wesnoth.get_variable(k)
    if old_v == nil then old_v = force_nil end
    old_values[k] = old_v
    wesnoth.set_variable(k,v)
  end
  string = (wesnoth.tovconfig{string=string}).string
  for k,v in pairs(old_values) do
    if v == force_nil then v = nil end
    wesnoth.set_variable(k,v)
  end
  return string
end

EoHS.is_on_the_map = { "filter_location", {} } -- TODO: confirm this works
EoHS.location_is_on_the_map = function(x,y,allow_fme)
  if (not x) or (not y) then return false end
  local w,h = wesnoth.get_map_size()
  if (x < 1) or (y < 1) or (x > w) or (y > h) then return false end
  if not allow_fme then
    local terrain = wesnoth.get_terrain(x, y)
    if (terrain == "_off^usr") or string.match(terrain, "%^_fme") then return false end
  end
  return true
end
-- Optional side, for circles of protection
EoHS.location_is_passable = function(x,y,side)
  if not EoHS.location_is_on_the_map(x,y) then return false end
  if EoHS.terrain_is_impassable(wesnoth.get_terrain(x,y)) then return false end
  local c = EoHS.context
  local p = c.petrified_units; if not p then p = {}; c.petrified_units = p end
  local idx = x..","..y
  local ph = p[idx]
  if ph == nil then
    local wunit = wesnoth.get_unit(x,y)
    if wunit and wunit.petrified then p[idx] = true; return false else p[idx] = false end
  elseif ph then return false end
  if side and EoHS.location_is_enemy_circle_of_protection(x,y,side) then return false end
  return true
end
EoHS.location_is_known_passable = function(x,y,side)
  return EoHS.location_is_passable(x,y,side) and EoHS.hex_is_unshrouded(x,y,side)
end

local hex_visibility_checker_unit = EoHS.create_wunit({side=1,type="Boat"})
EoHS.hex_is_unfogged = function(x, y, side)
  if wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0") then
    return wesnoth.match_location(x, y, { { "filter_vision", { side = side or wesnoth.current.side }} })
  else
    hex_visibility_checker_unit.x = x
    hex_visibility_checker_unit.y = y
    return wesnoth.match_unit(hex_visibility_checker_unit, { { "filter_vision", { viewing_side = side or wesnoth.current.side }} })
  end
end
EoHS.hex_is_unshrouded = function(x, y, side)
  -- Processing the filter seems to be much slower than the table lookups.
  --if wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0") then
  --  return wesnoth.match_location(x, y, { { "filter_vision", { side = side or wesnoth.current.side, respect_fog = false }} })
  --else
    if not side then side = wesnoth.current.side end
    if not wesnoth.sides[side].shroud then return true end
    local c = EoHS.context
    local si = c.shroud_info
    if not si then si = {}; c.shroud_info = si end
    local s = si[side]
    if not s then
      s = {}; si[side] = s
      local w,h,b = wesnoth.get_map_size()
      local sx = -b
      for line in string.gmatch(wesnoth.sides[side].__cfg.shroud_data, "|(.-)\n") do
        sx = sx + 1
        local sc = {}; s[sx] = sc
        local sy = -b
        for datum in string.gmatch(line, ".") do
          sy = sy + 1
          sc[sy] = datum == "1"
        end
      end
    end
    s = s[x]
    if not s then return false end
    return s[y]
  --end
end

local debug_check_unison_unit_tables = function()
  if EoHS.get_variable("debug_mode") and EoHS.context.unison then
    for k,v in pairs(EoHS.context.unison_unit_tables) do
      EoHS.assert(EoHS.context.unison_unit_tables[EoHS.unit_id(v)] == v)
      EoHS.assert(EoHS.context.unison_unit_tables[v.x..","..v.y] == v)
    end
  end
end
local record_unit = function(unit)
  -- Standardize every unit EoHS looks at.
  -- Standarization takes less time than simply copying (or Wesnoth dumping) a unit table,
  --   so it isn't too bad performance-wise to do it here.
  -- TODO: we used to not do this, so there are various unnecessary standardize_unit calls
  --   in various parts of the code. TODO remove them.
  local needed_standardized = EoHS.standardize_unit(unit, {dont_update_graphics=true})

  local id = EoHS.unit_id(unit)
  if EoHS.context.unison then
    EoHS.context.unison_unit_tables[unit.x..","..unit.y] = unit
    EoHS.assert(id, "Unit has no ID after standardization in unison?")
    EoHS.context.unison_unit_tables[id] = unit
    if needed_standardized then EoHS.put_unit(unit) end
  else
    EoHS.context.disunified_unit_tables[unit.x..","..unit.y] = unit
    if id then EoHS.context.disunified_unit_tables[id] = unit end
  end
  debug_check_unison_unit_tables()
end
local retrieve_unit = function(arg1, arg2)
  local unit,index
  if arg2 then index = arg1..","..arg2
  else         index = arg1 end
    
  if EoHS.context.unison then
    unit = EoHS.context.unison_unit_tables[index]
  else
    unit = EoHS.context.disunified_unit_tables[index]
    if EoHS.context.unison_unit_tables and not unit then
      unit = EoHS.deep_copy(EoHS.context.unison_unit_tables[index])
      if unit then
        record_unit(unit)
      end
    end
  end
  return unit
end

local xy_sort = function(a,b)
  if a.x < b.x then return true  end
  if b.x < a.x then return false end
  return a.y < b.y
end
EoHS.make_new_unit_id = function()
  EoHS.assert(EoHS.context.unison, "EoHS.make_new_unit_id used in an disunified context")
  local id = EoHS.get_variable("next_unit_id")
  EoHS.set_variable("next_unit_id", id + 1)
  return id
end
EoHS.get_units = function(filter)
  local wunits = wesnoth.get_units(filter)
  
  -- I've been told there's a bug in 1.10 that makes the order of filtered units
  -- not be consistent. Therefore, I need to sort them myself by something consistent
  -- (their location). I could make this 1.10-specific, but I don't see sufficient reason
  -- to trust that this behavior is correct and will remain correct.
  table.sort(wunits, xy_sort)
  
  local result = {}
  for i,wunit in ipairs(wunits) do
    if not wunit.petrified then -- Petrified units are obstructions, not units
      local unit = retrieve_unit(wunit.x, wunit.y)
      if not unit then
        unit = wunit.__cfg
        if EoHS.context.unison then EoHS.context.unison_wunits[unit] = wunit end
        record_unit(unit)
      end
      if unit then table.insert(result, unit) end
    end
  end
  
  -- Whenever we get units, unique the IDs...
  -- ...doing it this way didn't work, and wasn't thorough enough anyway.
  -- TODO: find the best way to unique the IDs
  --[[if EoHS.context.unison then
    local ids = {}
    for i,unit in ipairs(result) do
      local id = EoHS.unit_id(unit)
      if ids[id] then
        id = EoHS.make_new_unit_id()
        EoHS.set_unit_variable_immediate(unit, id)
      end
      ids[id] = true
    end
  end]]
  return result
end

EoHS.get_unit = function(arg1, arg2)
  local unit = retrieve_unit(arg1, arg2)
  if not unit then
    local wunit
    if arg2 then
      wunit = wesnoth.get_unit(arg1, arg2)
    else
      -- Hack: shadowm told me that scripts should basically never use underlying_id,
      -- so I converted EoHS to generate its own IDs, and made EoHS.get_unit take either an x,y
      -- or an EoHS unit id. TODO consider making this be two separate functions.
      wunit = wesnoth.get_units({ EoHS.is_on_the_map, EoHS.has_unit_variable("id", arg1) })[1]
    end
    if wunit and not wunit.petrified then -- Petrified units are obstructions, not units
      EoHS.assert(tonumber(wunit.x), "EoHS.get_unit got a unit with invalid x value")
      EoHS.assert(tonumber(wunit.y), "EoHS.get_unit got a unit with invalid y value")
      unit = wunit.__cfg
      if EoHS.context.unison then EoHS.context.unison_wunits[unit] = wunit end
      record_unit(unit)
    end
  end
  return unit
end

EoHS.get_seen_unit = function(x,y,viewing_side)
  local unit = EoHS.get_unit(x,y)
  if not unit then return nil end
  local unfogged = EoHS.hex_is_unfogged(x,y,viewing_side)
  if not unfogged then return nil end
  if EoHS.game_action_simulations.unit_wunit_is_hidden(unit, wesnoth.get_unit(x,y), viewing_side) then return nil end
  return unit
end

EoHS.at_beginning_of_event_get_autostored_unit = function(varname)
  -- One too many times did I fail to update this to be consistent with EoHS.get_unit,
  -- and its only purpose anyway was to save a miniscule amount of time.
  -- Just use get_unit. TODO probably remove all uses of this
  local x,y = wesnoth.get_variable(varname..".x"), wesnoth.get_variable(varname..".y")
  if x and y then return EoHS.get_unit(x,y) end
  --[[
  local unit = wesnoth.get_variable(varname)
  if unit then
    record_unit(unit)
    EoHS.context.unison_wunits[unit] = wesnoth.get_unit(unit.x, unit.y)
    return unit
  end
  ]]
end

EoHS.transformed_unit = function(unit, unit_type)
  local proxy_unit = EoHS.create_wunit(unit)
  wesnoth.transform_unit(proxy_unit, unit_type or unit.type)
  local result = proxy_unit.__cfg
  result.hitpoints = unit.hitpoints
  return result
end

EoHS.transform_unit = function(unit, unit_type)
  EoHS.shallow_overwrite(unit, EoHS.transformed_unit(unit, unit_type))
end

EoHS.put_unit = function(unit, options)
  local x = tonumber(unit.x)
  local y = tonumber(unit.y)
  if (not x) or (not y) then EoHS.err("EoHS.put_unit at "..unit.x..","..unit.y..", which is not a location") end
  local w,h = wesnoth.get_map_size()
  if (x < 1) or (y < 1) or (x > w) or (y > h) then EoHS.err("EoHS.put_unit at "..unit.x..","..unit.y..", which is off the map") end
  EoHS.assert(EoHS.context.unison, "EoHS.put_unit used in an disunified context")
  EoHS.assert(EoHS.context.unison_unit_tables, "EoHS.put_unit called not during an event")
  if not (options and options.allow_new_location) then
    EoHS.assert(EoHS.context.unison_unit_tables[unit.x..","..unit.y] == unit, "EoHS.put_unit: This unit is being put back at a different location when it's not supposed to be?")
  end
  local id = EoHS.unit_id(unit)
  if options and options.allow_overwrite then
    EoHS.remove_unit(x,y)
  else
    local wunit_here = wesnoth.get_unit(x,y)
    if wunit_here then
      local wid = EoHS.unit_id(wunit_here)
      EoHS.assert((not wid) or (wid == id), "EoHS.put_unit overwriting another unit")
    end
  end
  if id then
    if not (options and options.allow_unknown_id) then
      EoHS.assert(EoHS.context.unison_unit_tables[id] == unit,
        "EoHS.put_unit: This unit has an ID already, but we didn't get it from the map with that ID, or it's no longer valid to put?")
    end
    EoHS.context.unison_unit_tables[id] = unit
  end
  EoHS.context.unison_unit_tables[unit.x..","..unit.y] = unit
  if options and options.immediate then
    EoHS.context.units_to_put[unit] = nil
    wesnoth.put_unit(unit)
    wesnoth.fire("capture_village",{x=unit.x,y=unit.y,side=unit.side})
    EoHS.context.unison_wunits[unit] = wesnoth.get_unit(unit.x,unit.y)
  else
    if not EoHS.context.units_to_put[unit] then
      table.insert(EoHS.context.units_to_put, unit)
      EoHS.context.units_to_put[unit] = true
    end
  end
  debug_check_unison_unit_tables()
end
EoHS.remove_unit = function(x,y)
  EoHS.assert(EoHS.context.unison, "EoHS.remove_unit used in an disunified context")
  EoHS.assert(EoHS.context.unison_unit_tables, "EoHS.remove_unit called not during an event")
  local unit = retrieve_unit(x, y)
  if unit then
    EoHS.context.unison_unit_tables[x..","..y] = nil
    EoHS.context.unison_unit_tables[EoHS.unit_id(unit)] = nil
    EoHS.context.units_to_put[unit] = nil
  end
  wesnoth.put_unit(x,y)
  debug_check_unison_unit_tables()
end
local allowed_immediate_attributes = {
  side=true, attacks_left=true, extra_recruit=true, advances_to=true, hitpoints=true, experience=true,
  moves=true, resting=true, hidden=true, role=true, facing=true, }
  
EoHS.set_unit_attribute_immediate = function(unit, attr, val)
  EoHS.assert(allowed_immediate_attributes[attr], "EoHS.set_unit_attribute_immediate with invalid attr "..attr)
  unit[attr] = val
  local unison_wunits = EoHS.context.unison_wunits
  if not unison_wunits then return end
  local wunit = unison_wunits[unit]
  if not wunit then return end
  wunit[attr] = val
end
EoHS.set_unit_variable_immediate = function(unit, varname, val)
  EoHS.set_unit_variable(unit, varname, val)
  local unison_wunits = EoHS.context.unison_wunits
  if not unison_wunits then return end
  local wunit = unison_wunits[unit]
  if not wunit then return end
  EoHS.set_unit_variable(wunit, varname, val)
end
EoHS.set_unit_status_immediate = function(unit, status, val)
  EoHS.set_subtag_attribute(unit, "status."..status, val)
  local unison_wunits = EoHS.context.unison_wunits
  if not unison_wunits then return end
  local wunit = unison_wunits[unit]
  if not wunit then return end
  wunit.status[status] = val
end

-- Table return values are stored and returned as references.
-- This is intentional, to save the time one would spend copying them.
-- Modifying the tables returned from a memoized function would cause problems.
EoHS.memoized_multi_argument = function(func)
  local results = {}
  return function(...)
    local result_container = results
    for i,a in EoHS.vararg(...) do
      local idx = type(a)..tostring(a)
      local next_result_container = result_container[idx]
      if not next_result_container then
        next_result_container = {}
        result_container[idx] = next_result_container
      end
      result_container = next_result_container
    end
    local result = result_container.memoized_any__result_
    if not result then
      result = pack(func(...))
      result_container.memoized_any__result_ = result
    end
    return unpack(result)
  end
end
EoHS.memoized_one_argument = function(func)
  local results = {}
  return function(a)
    local result = results[a]
    if not result then
      result = pack(func(a))
      results[a] = result
    end
    return unpack(result)
  end
end

-- Returns a reference - if you want to modify the unit type, make your own copy
EoHS.get_unit_type = EoHS.memoized_one_argument(function(unit_type) return wesnoth.unit_types[unit_type].__cfg end)
EoHS.get_unit_type_generic_example = EoHS.memoized_one_argument(function(unit_type)
  return EoHS.create_wunit({type=unit_type, random_traits=false, random_gender=false, generate_name=false}).__cfg end)

EoHS.shallow_copy = function(input)
  if type(input) ~= "table" then return input end
  local result = {}
  for k,v in pairs(input) do result[k]=v end
  return result
end
EoHS.shallow_overwrite = function(dst, src)
  for k,v in pairs(dst) do dst[k]=nil end
  for k,v in pairs(src) do dst[k]=v end
end
EoHS.deep_overwrite = function(dst, src)
  for k,v in pairs(dst) do dst[k]=nil end
  for k,v in pairs(src) do dst[k]=EoHS.deep_copy(v) end
end

EoHS.canonicalized_attribute = function(attr)
  EoHS.set_variable("LUA_TEMP", attr)
  attr = EoHS.get_variable("LUA_TEMP")
  EoHS.set_variable("LUA_TEMP")
  return attr
end

EoHS.tags_are_identical = function(tag1, tag2)
  local one_sided = function(tag1, tag2)
    for k,v1 in pairs(tag1) do
      local v2 = tag2[k]
      if getmetatable(v1) == "translatable string" then
        -- ignore translatable strings.
      elseif type(v1) == "table" then
        -- the only tables are subtags, with the requisite format.
        if type(v2) ~= "table" then return false end
        if v2[1] ~= v1[1] then return false end
        if not EoHS.tags_are_identical(v1[2], v2[2]) then return false end
      else
        -- these could be strings, numbers... EoHS.canonicalized_attribute() them all because we might have issues e.g. 1 vs "1.0"
        if EoHS.canonicalized_attribute(v1) ~= EoHS.canonicalized_attribute(v2) then return false end
      end
    end
    return true
  end
  return one_sided(tag1, tag2) and one_sided(tag2, tag1)
end

EoHS.tag_diff = function(tag1, tag2)
  local infos = {}
  local function f(tag1, tag2)
    local one_sided = function(tag1, tag2, name1, name2, normal_order)
      for k,v1 in pairs(tag1) do
        local v2 = tag2[k]
        if getmetatable(v1) == "translatable string" then
          -- ignore translatable strings.
        elseif type(v1) == "table" then
          -- the only tables are subtags, with the requisite format.
          if type(v2) ~= "table" then table.insert(infos, name2.." has ["..v1[1].."] at position "..k.." missing")
          elseif v2[1] ~= v1[1] then table.insert(infos, name1.." has ["..v1[1].."] at position "..k..", but "..name2.." has ["..v2[1].."]")
          elseif normal_order then
            local str = "in ["..v1[1].."] at position "..k..":"
            table.insert(infos, str)
            f(v1[2],v2[2])
            if infos[#infos] == str then infos[#infos] = nil end
          end
        else
          -- these could be strings, numbers... EoHS.canonicalized_attribute() them all because we might have issues e.g. 1 vs "1.0"
          if EoHS.canonicalized_attribute(v1) ~= EoHS.canonicalized_attribute(v2) then table.insert(infos, name1.." has "..k.."="..tostring(v1)..", but "..name2.." has "..k.."="..tostring(v2)) end
        end
      end
      return true
    end
    one_sided(tag1, tag2, "tag 1", "tag 2", true)
    one_sided(tag2, tag1, "tag 2", "tag 1", false)
  end
  f(tag1, tag2)
  if not infos[1] then return nil end
  return table.concat(infos, "\n")
end

EoHS.comma_separated_values = function(s)
  return string.gmatch(s, "[^%s,][^,]*")
end
EoHS.lua_pattern_escape = function(s)
  return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'):gsub('%z','%%z'))
end

EoHS.get_subtag = function(table_, subtag_path)
  local last_idx
  for name in string.gmatch(subtag_path, "[^.]+") do
    if not table_ then return nil end
    table_,last_idx = helper.get_child(table_, name)
  end
  return table_,last_idx
end
EoHS.force_subtag = function(table_, subtag_path)
  local last_idx
  for name in string.gmatch(subtag_path, "[^.]+") do
    local subtag,index = helper.get_child(table_, name)
    if subtag then
      table_,last_idx = subtag,index
    else
      if table_[name] ~= nil then EoHS.err("EoHS.force_subtag overwrote an attribute with a tag") end
      table.insert(table_, { name, {} })
      table_,last_idx = table_[#table_][2],#table_
    end
  end
  return table_,last_idx
end
EoHS.get_subtag_attribute = function(table_, path)
  local current = table_
  for name in string.gmatch(path, "[^.]+") do
    if type(current) ~= "table" then return nil end
    local next = helper.get_child(current, name)
    if next then
      current = next
    else
      current = current[name]
    end
  end
  return current
end
EoHS.set_subtag_attribute = function(table_, path, value)
  local path_list = {}
  for name in string.gmatch(path, "[^.]+") do
    table.insert(path_list, name)
  end
  for i,name in ipairs(path_list) do
    local subtag,index = helper.get_child(table_, name)
    if path_list[i+1] then
      if subtag then
        table_ = subtag
      else
        if table_[name] ~= nil then EoHS.err("EoHS.set_subtag_attribute overwrote an attribute with a tag in the middle") end
        table.insert(table_, { name, {} })
        table_ = table_[#table_][2]
      end
    else
      if type(value) == "table" then
        if table_[name] ~= nil then EoHS.err("EoHS.set_subtag_attribute overwrote an attribute with a tag") end
        if subtag then
          table_[index][2] = value
        else
          table.insert(table_, { name, value })
        end
      else
        if subtag then
          if value ~= nil then
            EoHS.err("EoHS.set_subtag_attribute overwrote a tag with an attribute")
          else
            table.remove(table_, index)
          end
        else
          table_[name] = value
        end
      end
    end
  end
end

EoHS.get_subtags = function(table_, subtag_path, accum)
  if not accum then accum = {} end
  local first, rest = string.match(subtag_path, "([^%.]+)%.(.*)")
  local find = function(subtag)
    if rest then EoHS.get_subtags(subtag, rest, accum) else table.insert(accum, subtag) end
  end
  if (first or subtag_path) == "*" then
    for i,sup    in             ipairs(table_)                       do find(sup[2]) end
  else
    for   subtag in helper.child_range(table_, first or subtag_path) do find(subtag) end
  end
  return accum
end

EoHS.remove_subtags = function(table_, subtag_path, id_or_func)
  local first, rest = string.match(subtag_path, "([^%.]+)%.(.*)")
  local num_removed = 0
  if rest then
    if first == "*" then
      for i,sup    in             ipairs(table_)        do num_removed = num_removed + EoHS.remove_subtags(sup[2], rest, id_or_func) end
    else
      for   subtag in helper.child_range(table_, first) do num_removed = num_removed + EoHS.remove_subtags(subtag, rest, id_or_func) end
    end
  else
    local i = 1
    while table_[i] do
      if ((subtag_path == "*") or (table_[i][1] == subtag_path)) and (
            (not id_or_func) or
            (table_[i][2].id == id_or_func) or
            ((type(id_or_func) == "function") and id_or_func(table_[i][2], table_[i][1]))
          ) then
        num_removed = num_removed + 1
        table_[i] = nil
        i = i + 1
      else
        if num_removed > 0 then
          table_[i-num_removed] = table_[i]
          table_[i] = nil
        end
        i = i + 1
      end
    end
  end
  return num_removed
end

EoHS.get_unit_effects = function(unit, options)
  local result = {}
  local modifications = helper.get_child(unit, "modifications")
  if modifications then
    local wunit_
    local wunit = function()
      if not wunit_ then wunit_ = EoHS.create_wunit(unit) end
      return wunit_
    end
    local do_effects = function(modification_type, path)
      for modification in helper.child_range(modifications, modification_type) do
        if not (options and options.exclude_id and (modification.id == options.exclude_id)) then
          for effect in helper.child_range(modification, "effect") do
            local filter = EoHS.get_subtag(effect, "filter")
            if not (filter and not wesnoth.match_unit(wunit(), filter)) then
              if not (effect.unit_type and not EoHS.value_is_in_comma_separated_list(unit.type, effect.unit_type)) then --TODO implement
                if not (effect.unit_gender and (unit.gender ~= effect.unit_gender)) then --TODO remove these in 1.11
                  for i=1,((effect.times == "per level") and unit.level or 1) do
                    table.insert(result, effect)
                  end
                end
              end
            end
          end
        end
      end
    end
    do_effects("advance")
    do_effects(  "trait")
    do_effects( "object")
  end
  return result
end
EoHS.has_unit_variable = function(varname, value)
  if value == nil then value = true end
  return  { "filter_wml", {
            { "variables", {
              ["EoHS_"..varname] = value
            }}
          }}
end

EoHS.find_path = function(x1,y1,x2,y2,cost_func,maximum)
  if maximum then
    return EoHS.find_path(x1,y1,x2,y2,function(x,y,current_cost)
      local cost = cost_func(x,y,current_cost)
      if not cost then return nil end
      if current_cost+cost+helper.distance_between(x,y,x2,y2) > maximum then return nil end
      return cost
    end)
  else
    return wesnoth.find_path(x1,y1,x2,y2,function(x,y,current_cost)
      local cost = cost_func(x,y,current_cost)
      if cost then
        if cost < 1 then EoHS.err("EoHS.find_path cost_func gave invalid cost") end
        if cost+current_cost >= 10000 then EoHS.err("EoHS.find_path exceeded wesnoth's arbitrary, undocumented limit") end
        return cost
      else
        return 10001
      end
    end)
  end
end
EoHS.distance_between = function(x1,y1,x2,y2,cost_func,maximum)
  if cost_func then
    local path,cost = EoHS.find_path(x1,y1,x2,y2,cost_func,maximum)
    return cost
  else
    return helper.distance_between(x1,y1,x2,y2)
  end
end

EoHS.find_reach = function(x1,y1,cost_func,maximum)
  local result = {}
  local frontier = EoHS.priority_queue(function(hex) return -hex.cost end)
  local found_hexes = {}
  local reach_hex = function(x,y,cost)
    if not (maximum and (cost > maximum)) then
      table.insert(result, {x=x,y=y,cost=cost})
      frontier.insert({x=x,y=y,cost=cost})
    end
  end
  local find_hex = function(x,y,old_cost)
    local idx = x..","..y
    if not found_hexes[idx] then
      found_hexes[idx] = true
      if old_cost then
        local cost = 1
        if cost_func then cost = cost_func(x,y,old_cost) end
        if cost then reach_hex(x,y,old_cost + cost) end
      else
        reach_hex(x,y,0)
      end
    end
  end
  find_hex(x1,y1)
  while frontier.top() do
    local start = frontier.pop()
    for x,y in helper.adjacent_tiles(start.x, start.y) do
      find_hex(x,y,start.cost)
    end
  end
  return result
end

EoHS.passable_only = function(side)
  return function(x, y, current_cost)
    if not EoHS.location_is_passable(x, y, side) then return nil end
    return 1
  end
end
EoHS.known_passable_only = function(side)
  return function(x, y, current_cost)
    if not EoHS.location_is_known_passable(x, y, side) then return nil end
    return 1
  end
end
  
EoHS.restrict_contained_filter = function(contents, filter_tagname, filter)
  for i,tag in ipairs(contents) do
    if tag[1] == filter_tagname then
      table.insert(contents, { "and", filter })
      return
    end
  end
  table.insert(contents, { filter_tagname, filter })
end

-- Returns a reference - if you want to modify the unit type, make your own copy
EoHS.unit_type_with_gender_and_variation = EoHS.memoized_multi_argument(function(unit_type, gender, variation)
  local result = EoHS.get_unit_type(unit_type)
  for i,tag in ipairs(result) do
    if tag[1] == "base_unit" then EoHS.err("A base_unit was left around, do we need to handle it?") end
    if (tag[1] == gender) or ((tag[1] == "variation") and ((tag[2].variation_id or tag[2].variation_name) == variation)) then
      if tag[2].inherit then
        wesnoth.set_variable("EoHS.LUA_TEMP", result)
        wesnoth.fire("set_variables", { name = "EoHS.LUA_TEMP", mode = "merge", { "literal", tag[2] }})
        result = wesnoth.get_variable("EoHS.LUA_TEMP")
        wesnoth.set_variable("EoHS.LUA_TEMP")
      else
        result = tag[2]
      end
    end
  end
  return result
end)

EoHS.unit_type_considering_variations = function(unit)
  return EoHS.unit_type_with_gender_and_variation(unit.type, unit.gender, unit.variation)
end

EoHS.check_wml_table = function(wml_table, prefix)
  if not prefix then prefix = "" end
  local err = function(str) EoHS.err("EoHS.check_wml_table"..prefix..": "..str) end
  if type(wml_table) == "table" then
    for k,v in pairs(wml_table) do
      if type(k) == "number" then
        if type(v) == "table" then
          if type(v[1]) == "string" then
            EoHS.check_wml_table(v[2],prefix.."["..v[1].."]")
          else
            err("Non-string tagname: ["..k.."] = "..EoHS.inspect(v, {depth=2}))
          end
        else
          err("Non-table at integer index: ["..k.."] = "..EoHS.inspect(v))
        end
      else
        if type(v) == "table" then
          err("Table at non-integer index: ["..k.."] = "..EoHS.inspect(v, {depth=1}))
        elseif type(v) == "function" then
          err("Attribute is a function: ["..k.."] = "..EoHS.inspect(v))
        end
      end
    end
  else
    EoHS.err("WML table is not a table at all, but "..EoHS.inspect(wml_table))
  end
  return wml_table
end

local function is_even(v) return (v % 2) == 0 end

EoHS.consistent_coordinates = function(x, y)
  y=y*2
  if is_even(x) then y = y + 1 end
  return x, y
end

EoHS.euclidean_coordinates = function(x, y)
  if is_even(x) then y = y + 0.5 end
  return x*1.5, y*math.sqrt(3)
end

EoHS.angle_between = function(x1, y1, x2, y2)
  x1, y1 = EoHS.euclidean_coordinates(x1, y1)
  x2, y2 = EoHS.euclidean_coordinates(x2, y2)
  return math.atan2(y2-y1, x2-x1)
end

EoHS.specific_and_simplified_directions_to_hex = function(x1, y1, x2, y2, approx)
  if x2 == x1 then
    if y2 < y1 then return "n","n" end
    if y2 > y1 then return "s","s" end
    return nil
  end
  
  x1,y1 = EoHS.consistent_coordinates(x1, y1)
  x2,y2 = EoHS.consistent_coordinates(x2, y2)
    
  local we = (x2 < x1) and "w" or "e"
  if y2 == y1 then return we,"s"..we end
  local ns = (y2 < y1) and "n" or "s"
  
      if math.abs(x1 - x2) * 5 < math.abs(y1 - y2) * 2 then return ns..ns..we, ns
  elseif math.abs(x1 - x2)     < math.abs(y1 - y2)     then return ns..ns..we, ns..we
  elseif math.abs(x1 - x2)    == math.abs(y1 - y2)     then return     ns..we, ns..we
  elseif math.abs(x1 - x2) * 2 < math.abs(y1 - y2) * 5 then return we..ns..we, ns..we
  else                                                  return             we, ns..we end
end

EoHS.face_towards = function(unit, x, y, strict)
  local tx,ty = EoHS.consistent_coordinates(     x,      y)
  local ax,ay = EoHS.consistent_coordinates(unit.x, unit.y)
  local facing_west = (unit.facing == "nw") or (unit.facing == "sw")
      if tx > ax then unit.facing = (ty<ay) and "ne" or "se"
  elseif tx < ax then unit.facing = (ty<ay) and "nw" or "sw"
  elseif ty == ay then -- ...
  elseif facing_west and not strict then
                      unit.facing = (ty<ay) and "nw" or "sw"
  else                unit.facing = (ty<ay) and "n"  or "s"  end
end

EoHS.relative_directions = {
  n= {"ne","se","s", "sw","nw"},
  ne={"se","s", "sw","nw","n" },
  se={"s", "sw","nw","n", "ne"},
  s= {"sw","nw","n", "ne","se"},
  sw={"nw","n", "ne","se","s" },
  nw={"n", "ne","se","s", "sw"},
}

EoHS.direction_clockwise_from = function(direction) return EoHS.relative_directions[direction][1] end
EoHS.direction_counterclockwise_from = function(direction) return EoHS.relative_directions[direction][5] end

EoHS.get_loc_in_direction = function(x, y, direction)
      if direction == "n" then return x, y - 1
  elseif direction == "s" then return x, y + 1
  else
    local mod = 0
    if x % 2 == 0 then mod = 1 end
        if direction == "ne" then return x + 1, y + mod - 1
    elseif direction == "nw" then return x - 1, y + mod - 1
    elseif direction == "se" then return x + 1, y + mod
    elseif direction == "sw" then return x - 1, y + mod
    end
  end
end

EoHS.same_relative_location = function(x, y, src_x, src_y, dst_x, dst_y)
  local result_x = x + (dst_x - src_x)
  local result_y = y + (dst_y - src_y)
  if is_even(dst_x) ~= is_even(src_x) and not (is_even(x - src_x)) then
    if is_even(dst_x) then result_y = result_y + 1
    else                   result_y = result_y - 1
    end
  end
  return result_x, result_y
end

EoHS.get_time_of_day = function(x,y,turn)
  wesnoth.fire("store_time_of_day", {
    x=x,y=y,variable="EoHS.LUA_TEMP",
  })
  local result = EoHS.get_variable("LUA_TEMP")
  EoHS.set_variable("LUA_TEMP")
  return result
end

EoHS.has_trait = function(unit, trait_id)
  local modifications = EoHS.get_subtag(unit, "modifications")
  if modifications then
    for i,mod in ipairs(modifications) do
      if (mod[1] == "trait") and (mod[2].id == trait_id) then
        return true
      end
    end
  end
  return false
end
EoHS.is_fearless = function(unit)
  return EoHS.has_trait(unit, "fearless")
end

EoHS.kill_experience = function(level)
  if level == 0 then return math.floor(wesnoth.game_config.kill_experience / 2) end
  return level * wesnoth.game_config.kill_experience
end

EoHS.unit_is_immune_to_direct_spell_damage = function(unit)
  return unit.canrecruit or EoHS.get_unit_variable(unit, "is_wizard") or (EoHS.get_unit_variable(unit, "ghost_protection"))
end
EoHS.unit_is_immune_to_direct_spell_damage_description = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    return _"Wizards block all spell damage."
  elseif EoHS.get_unit_variable(unit, "ghost_protection") then
    return _"Ghosts are immune to spell damage."
  elseif unit.canrecruit then
    return _"Leaders are immune to spell damage."
  else
    return _"That unit is immune to spell damage."
  end
end

EoHS.wunit_can_move_on_hex = function(wunit, x, y)
  local movement_cost = wesnoth.unit_movement_cost(wunit, wesnoth.get_terrain(x, y))
  return movement_cost and (movement_cost > 0) and (movement_cost <= wunit.max_moves)
end
EoHS.unit_is_immobile = function(unit)
  if unit.max_moves <= 0 then return true end
  local movement_costs = EoHS.get_subtag(unit, "movement_costs")
  if not movement_costs then return true end
  for k,v in pairs(movement_costs) do
    if (v > 0) and (v <= unit.max_moves) then return false end
  end
  return true
end

EoHS.prepare_max_moves_change = function(unit)
  local best_max_moves_this_turn = math.max(EoHS.get_unit_variable(unit, "best_max_moves_this_turn") or 0, unit.max_moves)
  EoHS.set_unit_variable(unit, "best_max_moves_this_turn", best_max_moves_this_turn)
  EoHS.set_unit_variable(unit, "moves_above_max", math.max(0, unit.moves - unit.max_moves))
end
EoHS.finish_max_moves_change = function(unit)
  local best_max_moves_this_turn = EoHS.get_unit_variable(unit, "best_max_moves_this_turn")
  EoHS.assert(best_max_moves_this_turn, "EoHS.finish_max_moves_change called without EoHS.prepare_max_moves_change first")
  if unit.max_moves > best_max_moves_this_turn then
    EoHS.set_unit_variable(unit, "best_max_moves_this_turn", unit.max_moves)
    if unit.moves ~= 0 then -- TODO hmm... is there any way we can cover the "walk your full five moves, then wraithform" case without allowing exploits?
      unit.moves = unit.moves + unit.max_moves - best_max_moves_this_turn
    end
  end
  local max_remaining = unit.max_moves + EoHS.get_unit_variable(unit, "moves_above_max")
  EoHS.set_unit_variable(unit, "moves_above_max")
  if unit.moves > max_remaining then
    unit.moves = max_remaining
  end
end

EoHS.shuffle = function(t)
  for i=2,#t do
    local j = EoHS.random("1.."..i)
    t[i],t[j] = t[j],t[i]
  end
end

EoHS.side_is_angerpersonified = function(side)
  return wesnoth.eval_conditional({
    {"have_unit",{ side=side, name="angerpersonified" }}
  })
end

EoHS.side_recruit_list = function(side)
  local list
  local side_recruits = wesnoth.sides[side].recruit
  for i,recruit in ipairs(side_recruits) do
    list = (list and list.."," or "")..recruit
  end
  return list or ""
end

-->>)}
