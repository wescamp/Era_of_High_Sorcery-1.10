this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- actions.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")

EoHS.unit_has_actions = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard") or (EoHS.has_unit_variable("is_summon") and ((unit.type == "Fire Dragon") or (unit.type == "Yeti")))
end
EoHS.soon(function() EoHS.unit_has_actions_filter = {"and",{
  EoHS.has_unit_variable("is_wizard"),
  {"or",{
    EoHS.has_unit_variable("is_summon"),
    type = "Fire Dragon,Yeti"
  }}
}} end)

EoHS.unit_has_action = function(unit, id)
  local actions = EoHS.unit_actions(unit)
  for i,id2 in ipairs(actions) do
    if id2 == id then return true end
  end
  return false
end

EoHS.unit_actions = function(unit)
  local result = {}
  if EoHS.get_unit_variable(unit, "ritual") then
    table.insert(result, "cancel_ritual")
  end
  if EoHS.get_unit_variable(unit, "spiritform") then
    table.insert(result, "end_spiritform")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "dispelling_touch" then
    table.insert(result, "use_dispelling_touch")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "reanimating_touch" then
    table.insert(result, "use_reanimating_touch")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "mud_touch" then
    table.insert(result, "use_mud_touch")
  end
  if EoHS.get_unit_skill(unit, "mentor") and EoHS.get_wizard_setting(unit, "can_recruit") then
    table.insert(result, "train_apprentice")
  end
  if EoHS.get_unit_variable(unit, "is_summon") then
    if unit.type == "Yeti" then
      table.insert(result, "earthworks")
    end
    if unit.type == "Fire Dragon" then
      table.insert(result, "dragon_breath")
    end
  end
  if EoHS.get_unit_variable(unit, "is_wizard") then
    if EoHS.get_resummonable_wunits(unit)[1] then table.insert(result, "resummon") end
    for i,spell_id in ipairs(EoHS.spells_known_from_skillset(EoHS.get_unit_skillset(unit))) do
      table.insert(result, spell_id)
      if spell_id == "summon_skeleton" then table.insert(result, "summon_skeleton_archer") end
      if spell_id == "summon_vampire_bat" then table.insert(result, "absorb_bats") end
    end
    --table.insert(result, "summon_wolf")
  end
  return result
end

local standard_action_aspects = {
  "ap","mana","range","target",
}
local g = function(contents) return { "grid", contents } end
local r = function(contents) return { "row", contents } end
local c = function(contents) return { "column", contents } end
local spacer = { "spacer", {}}

EoHS.action_list_entry_canvas = function(strings, image)
  local result = {}
  
  local texts = {
    { w = 200, },
    { w = 25, },
    { w = 45, },
    { w = 50, },
    { w = 90, },
  }
  for i,string in ipairs(strings) do
    local text = texts[i]
    text.y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED
    if texts[i-1] then
      text.x = texts[i-1].x + texts[i-1].w + 3
    else
      text.x = 6
    end
    text.h = "(text_height)"
    text.font_size = 14
    text.color = EoHS.validity_color(string[1])
    text.text = string[2]
  end
  for i,text in ipairs(texts) do
    text.x = "("..(text.x+text.w).."-text_width)"
    table.insert(result, {"text",text})
  end
  if image then
    table.insert(result, {"image",{
      x=0,y=0,w="(height)",h="(height)",
      name=image,
    }})
  end
  
  return result
end
local action_list_entry_size_str = "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\nm"


EoHS.action_dialog_stuff = function(dialog_context, parameters, ghost_distance_to_target, list_entry_only, selected, switch_func_func)
  local action = EoHS.actions[parameters.action_id]
  
  local cost = EoHS.action_cost(parameters)
  local range = EoHS.action_range(parameters)
  local whole_action_validity = "valid"
  local actor
  local action_image = action.image
  if parameters.actor_id then
    actor = EoHS.get_unit(parameters.actor_id)
    action_image = EoHS.mod_all_component_images(action_image, EoHS.TC_image_mod(actor.side, "magenta"))
  end
  
  local standard_aspects = {}
  local extra_aspects = {}
  local make_aspect = function(type_label, value_label, details_label, validity, index)
    if not validity then validity = "valid" end
    if validity == "impossible" then whole_action_validity = "impossible" end
    if validity == "undesirable" and whole_action_validity == "valid" then whole_action_validity = "undesirable" end
    if list_entry_only then
      if index then standard_aspects[index] = { validity, value_label } end
    else
      local    type_widget = EoHS.label_with_validity(dialog_context, validity, {label=    type_label}, "right")
      local   value_widget = EoHS.label_with_validity(dialog_context, validity, {label=   value_label}, "left")
      local details_widget = {"label",{wrap=true,characters_per_line=40,label= details_label}}
      local row = r{
        c{horizontal_grow=true, border="right", border_size=9, type_widget},
        c{horizontal_grow=true, border="right", border_size=9, value_widget},
        c{horizontal_grow=true, border="right", border_size=9, details_widget},
      }
      if index then standard_aspects[index] = row
      else table.insert(extra_aspects, row) end
    end
  end
  if (action.id ~= "end_spiritform") and EoHS.get_unit_variable(actor, "spiritform") then
    make_aspect(_"Transformed:", "", _"You can't use actions while transformed.", "impossible")
  end
  if action.target_type and EoHS.location_is_enemy_circle_of_protection(parameters.target_x, parameters.target_y, actor.side) then
    make_aspect(_"Circle of protection:", "", _"You can't target any action at an enemy circle of protection.", "impossible")
  end
  if cost.action_points then
    make_aspect(_"AP:", ""..cost.action_points, "", (EoHS.get_unit_action_points(actor) >= cost.action_points) and "valid" or "impossible", "ap")
  end
  if cost.mana then
    local mana = math.max(0, EoHS.get_unit_variable(actor, "mana"))
    local validity = "valid"
    local label
    local details = ""
    if mana >= cost.mana then
      label = ""..cost.mana
    elseif EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells") and (mana+wesnoth.sides[actor.side].gold >= cost.mana) then
      details = EoHS.substitute(_"You will transmute $1| gold into mana", {cost.mana-mana})
    else
      validity = "impossible"
    end
    make_aspect(_"Mana cost:", ""..cost.mana, details, validity, "mana")
  end
  if cost.gold then
    make_aspect(_"Gold cost:", ""..cost.gold, "", (wesnoth.sides[actor.side].gold >= cost.gold) and "valid" or "impossible")
  end
  if action.target_type then
    local target_type = action.target_type(parameters)
    make_aspect(_"Target type:", list_entry_only and target_type.short_name or target_type.name, target_type.details, target_type.validity, "target")
    
    if range then
      make_aspect(_"Range:", ""..range, "", (ghost_distance_to_target and (ghost_distance_to_target <= range)) and "valid" or "impossible", "range")
    end
  end
  if action.make_extra_attributes then
    action.make_extra_attributes(parameters, {
      type_value_and_details = make_aspect,
      type_and_details = function(t,d,v) make_aspect(t,"",d,v) end,
    }, list_entry_only)
  end
  
  if list_entry_only then
    local strings = {
      { whole_action_validity, action.name },
    }
    for i,id in ipairs(standard_action_aspects) do
      table.insert(strings, standard_aspects[id] or {"valid", ""})
    end
    --TODO damage entry
    
    return r{c{EoHS.fake_listbox_entry(dialog_context, action_list_entry_size_str, EoHS.action_list_entry_canvas(strings, action_image), selected, switch_func_func(parameters.action_id))}}, whole_action_validity
  else
    local aspect_rows = {}
    for i,id in ipairs(standard_action_aspects) do
      if standard_aspects[id] then
        table.insert(aspect_rows, standard_aspects[id])
      end
    end
    for i,aspect in ipairs(extra_aspects) do
      table.insert(aspect_rows, aspect)
    end
    
    local rows = {}
    if action.extra_parameters_dialog_grid then
      local grid = action.extra_parameters_dialog_grid(dialog_context, parameters)
      if grid then table.insert(rows, r{c{grid}}) end
    end
    table.insert(rows, r{c{ horizontal_grow=true, border="all",border_size=9, 
        g{r{
          c{ vertical_alignment="top",border="right",border_size=4, {"image",{label=action_image}} },
          c{ horizontal_grow=true,grow_factor=2, g{
            r{c{horizontal_alignment="left",{"label",{label=action.name,definition="title"}} }},
            r{c{horizontal_alignment="left",border="all",border_size=9, {"label",{wrap=true,characters_per_line=70,label=action.description}} }}
          }}
        }}
      }})
    table.insert(rows, r{c{g(aspect_rows)}})
    return g(rows), whole_action_validity
  end
end

EoHS.actions_grid = function(dialog_context, parameters, subjects_grid, target_grid_func, switch_func_func)
  local actor = EoHS.get_unit(parameters.actor_id)
  local ghost_distance_to_target
  if parameters.target_x then
    ghost_distance_to_target = EoHS.distance_between(
          actor.       x,      actor.       y,
     parameters.target_x, parameters.target_y,
     EoHS.known_passable_only(actor.side), 100)
  end
  local cost = (parameters.action_id and EoHS.action_cost(parameters)) or {}
  local resource_rows = {}
  local make_resource_row = function(name, amount, spent)
    local validity = (spent and (amount < spent)) and "impossible" or "valid"
    local cols = {
      c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity, { definition = "default_large", label = name   }, "right") },
      c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "valid" , { definition = "default_large", label = amount }, "right") },
    }
    if spent then
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "undesirable", { definition = "default_large", label = " - "          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "undesirable", { definition = "default_large", label = spent          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity,      { definition = "default_large", label = " = "          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity,      { definition = "default_large", label = (amount-spent) }, "right") })
    else
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
    end
    table.insert(resource_rows, r(cols))
  end
  
  local mana = EoHS.get_unit_variable(actor, "mana")
  local can_spend_gold_on_spells = EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells")
  make_resource_row(_"Mana: ", mana, (can_spend_gold_on_spells and cost.mana) and math.min(mana,cost.mana) or cost.mana)
  if can_spend_gold_on_spells or cost.gold then
    local gold = wesnoth.sides[actor.side].gold
    make_resource_row(_"Gold: ", gold, (cost.mana or cost.gold) and ((cost.gold or 0) + math.max(0, (cost.mana or 0) - mana)))
    if can_spend_gold_on_spells then
      make_resource_row(_"Total: ", mana+gold, (cost.mana or cost.gold) and ((cost.mana or 0) + (cost.gold or 0)))
    end
  end
  make_resource_row(_"AP: ", EoHS.get_unit_action_points(actor), cost.action_points)
  
  -- TODO: display ghost_distance_to_target vs. range
  
  local actions_you_have_grid
  local target_grid
  if parameters.action_id then
    local standard_action_aspect_names = {
      ap=_"AP",mana=_"Mana",target=_"Target",range=_"Range",
    }
    local key_strings = {{"valid",""}}
    for i,id in ipairs(standard_action_aspects) do
      table.insert(key_strings, { "valid", standard_action_aspect_names[id] })
    end
    --TODO damage entry
    local key_label = {"label",{id = dialog_context.make_unique_id(), label="mmmmmmmmm"}}
    dialog_context.preshow(function()
      wesnoth.set_dialog_canvas(1, EoHS.action_list_entry_canvas(key_strings), key_label[2].id)
    end)
    
    local rows = {}
    local rolling_parameters = EoHS.deep_copy(parameters)
    local actions = EoHS.unit_actions(actor)
    --TODO: "all actions / known actions / usable actions"
    for i,id in ipairs(actions) do
      rolling_parameters.action_id = id
      local row, validity = EoHS.action_dialog_stuff(dialog_context, rolling_parameters, ghost_distance_to_target, true, rolling_parameters.action_id==parameters.action_id, switch_func_func)
      table.insert(rows, row)
    end
    local list_grid
    if #rows > 7 then
      list_grid = g{r{c{ {"spacer",{height=190}} },c{vertical_grow=true, g{
        r{c{horizontal_grow=true, border="bottom", border_size=3, key_label}},
        r{ grow_factor=2, c{vertical_grow=true, {"scrollbar_panel",{ horizontal_scrollbar_mode="never", {"definition", rows } }} }}
      }} }}
    else
      list_grid = g{
        r{c{horizontal_grow=true, border="bottom", border_size=3, key_label}},
        r{ grow_factor=2, c{vertical_grow=true, g(rows) }}
      }
    end
  
    local action = EoHS.actions[parameters.action_id]
    local grid, current_action_validity = EoHS.action_dialog_stuff(dialog_context, parameters, ghost_distance_to_target)
    local cast_str
    local thumbnail_size_str = "mmmmmmm"
    local button_size_str
    local use = _"Use"
    if action.is_spell then use = _"Cast" end
    if action.is_ritual then use = _"Start casting" end
    if action.target_type then
      local target_unit = EoHS.get_seen_unit(parameters.target_x, parameters.target_y, actor.side)
      local target_str
      if target_unit then
           cast_str = EoHS.substitute(_"$use| <b>$1|</b> at <b>$4|</b> ($2|,$3|)", {use=use, action.name, parameters.target_x, parameters.target_y, EoHS.unit_appellation(target_unit)})
      else cast_str = EoHS.substitute(_"$use| <b>$1|</b> at ($2|,$3|)",            {use=use, action.name, parameters.target_x, parameters.target_y}) end
      button_size_str = cast_str..thumbnail_size_str
    else
      cast_str = EoHS.substitute(_"$use| <b>$1|</b>", {use=use, action.name})
      button_size_str = cast_str
    end
    button_size_str = string.gsub(button_size_str, "%b<>", "")
    -- lolhack: account for the fact that the button-sizing is based on a different size of text than what I write in afterwards
    button_size_str = button_size_str..string.rep("m",math.ceil(string.len(button_size_str)/7))
    -- Hack: obs and off-turn can't *cast* spells, but display the rest of the dialog accurately.
    if (actor.side ~= wesnoth.current.side) or (wesnoth.sides[actor.side].controller ~= "human") then
      current_action_validity = "impossible"
    end
    local canvas = { {"text",{
      x = action.target_type and EoHS.macros.GUI__TEXT_HORIZONTALLY_CENTRED or "(width-text_width-12)",
      y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED,
      w = "(text_width)",
      h = "(text_height)",
      font_size = 14,
      color = EoHS.validity_color(current_action_validity),
      text = cast_str,
      text_markup = true
    }} }
    if action.target_type then
      EoHS.add_hex_canvas(canvas, parameters.target_x, parameters.target_y, actor.side, {
        x = "(width-(10+image_width))",
        y = "((height/2)-(image_height/2))",
        w = "(if(height<58,height,58))",
        h = "(if(height<58,height,58))",
      })
    end
    button_size_str = "m\nm\n"..thumbnail_size_str..button_size_str.."\nm\nm"
    EoHS.add_hex_canvas(canvas, actor.x, actor.y, actor.side, {
      x = "10",
      y = "((height/2)-(image_height/2))",
      w = "(if(height<58,height,58))",
      h = "(if(height<58,height,58))",
    })
    local cast_button = {"button",{id="ok",label=button_size_str}}
    dialog_context.preshow(function()
      EoHS.set_canvas_over_button(canvas, "ok")
    end)
    if current_action_validity == "impossible" then
      dialog_context.preshow(function() wesnoth.set_dialog_active(false, "ok") end)
    end
    actions_you_have_grid = g{
      r{ c{ border="all", border_size=4, list_grid }, },
      r{ c{ cast_button, } },
      r{ c{ border="top", border_size=4, grid }, },
    }
    
    
    local target_icon = function(name)
      return {"image",{
        x="((width-image_width)/2)",
        y="((height-image_height)/2)",
        w="(if(width<image_original_width,width,image_original_width))",
        h="(if(height<image_original_height,height,image_original_height))",
        name=name
      }}
    end
    local affected_hexes = action.affected_hexes and action.affected_hexes(parameters, "known") or {}
    local hex_image_mods_and_canvas_extras_map = {}
    for i,hex in ipairs(affected_hexes) do
      local idx = hex.x..","..hex.y
      if hex.visual == "harm" then
        local canvas = { target_icon("misc/new-battle.png~O(0.8)") }
        EoHS.add_canvas_hex_border_25x25(canvas, "255, 0, 0, 255", 2)
        hex_image_mods_and_canvas_extras_map[idx] = { "~CS(50,0,0)", canvas }
      end
      if hex.visual == "help" then
        local canvas = { target_icon("misc/capture.png~CROP(40,51,13,13)~O(0.8)") }
        EoHS.add_canvas_hex_border_25x25(canvas, "0, 255, 0, 255", 2)
        hex_image_mods_and_canvas_extras_map[idx] = { "~CS(0,50,0)", canvas }
      end
      if hex.visual == "change" then
        local canvas = { target_icon("misc/reloaded.png~O(0.8)") }
        EoHS.add_canvas_hex_border_25x25(canvas, "255, 255, 0, 255", 2)
        hex_image_mods_and_canvas_extras_map[idx] = { "~CS(40,40,0)", canvas }
      end
    end
    --[[local actor_idx = actor.x..","..actor.y
    if not hex_image_mods_and_canvas_extras_map[actor_idx] then
      local canvas = {}
      EoHS.add_canvas_hex_border_25x25(canvas, "0, 200, 255, 255", 2)
      hex_image_mods_and_canvas_extras_map[actor_idx] = { "~CS(0,40,50)", canvas }--{ "", { target_icon("misc/zoc.png~CROP(26,51,20,18)~O(0.8)") } }
    end]]
    target_grid = target_grid_func(function(x,y)
      local stuff = hex_image_mods_and_canvas_extras_map[x..","..y]
      if stuff then
        return unpack(stuff)
      end
    end)
  else
    actions_you_have_grid = g{r{c{ border="all", border_size=14, {"label",{label=_"You have no actions to use."}} }}}
    target_grid = target_grid_func(function(x,y) return end)
  end
  return g{
    r{c{horizontal_grow=true, g{r{c{ border="all", border_size=12, g(resource_rows) },c{horizontal_grow=true, grow_factor=2, vertical_alignment="top", subjects_grid}}}}},
    r{c{g{r{c{actions_you_have_grid},c{vertical_alignment="top", target_grid}}}}},
  }
end

EoHS.do_action = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local actor = EoHS.get_unit(parameters.actor_id)
  local cost = EoHS.action_cost(parameters)
  local affected_hexes = action.affected_hexes and action.affected_hexes(parameters, "actual") or {}
  for i,hex in ipairs(affected_hexes) do
    if hex.require_no_invisible_enemy then
      local unit = EoHS.get_unit(hex.x,hex.y)
      if unit and wesnoth.is_enemy(unit.side, actor.side) then
        EoHS.do_only_on_client_controlling_side(actor.side, function()
          EoHS.message(EoHS.substitute(_"Your action ($3|) was disrupted by an invisible unit at ($1|,$2|). Try again.", {hex.x,hex.y,action.name}))
        end)
        return
      end
    end
  end
  EoHS.pay_action_cost(parameters, cost)
  
  -- Wizards cannot be invisible while casting!
  EoHS.set_unit_status_immediate(actor, "uncovered", true)
  
  local sides_who_can_see_action = {}
  for side in ipairs(wesnoth.sides) do
    if not wesnoth.is_enemy(side, actor.side) then sides_who_can_see_action[side] = true end
    if action.affected_hexes and not sides_who_can_see_action[side] then
      for i,hex in ipairs(affected_hexes) do
        if not hex.hidden_from_enemies then
          if EoHS.hex_is_unfogged(hex.x, hex.y, side) then
            sides_who_can_see_action[side] = true
            break
          end
        end
      end
    end
    if parameters.actor_id and not sides_who_can_see_action[side] then
      if EoHS.get_seen_unit(actor.x, actor.y, side) then
        sides_who_can_see_action[side] = true
      end
    end
  end
    
  -- disunified: each client displays its own cast message
  local local_client_can_see = false
  local local_client_controls_any_side = false
  EoHS.disunified(function()
    for side in ipairs(wesnoth.sides) do
      if (wesnoth.sides[side].controller == "human") or (wesnoth.sides[side].controller == "human_ai") then
        local_client_controls_any_side = true
        if sides_who_can_see_action[side] then local_client_can_see = true end
      end
      if local_client_can_see then break end
    end
    if not local_client_controls_any_side then local_client_can_see = true end -- observers get to see everything
    if local_client_can_see then
      local use_message, extra_values = action.use_message
      if type(use_message) == "function" then use_message, extra_values = use_message(parameters) end
      if not use_message then
        if action.target_type then
          local seen_target_unit = EoHS.get_unit(parameters.target_x, parameters.target_y)
          if local_client_controls_any_side and seen_target_unit then
            seen_target_unit = nil
            for side in ipairs(wesnoth.sides) do
              if (wesnoth.sides[side].controller == "human") or (wesnoth.sides[side].controller == "human_ai") then
                seen_target_unit = EoHS.get_seen_unit(parameters.target_x, parameters.target_y, side)
              end
              if seen_target_unit then break end
            end
          end
          if seen_target_unit then
               use_message = _"$actor_name| ($actor.x|,$actor.y|) $uses| $action.name| at $target_name| ($target.x|,$target.y|)."
          else use_message = _"$actor_name| ($actor.x|,$actor.y|) $uses| $action.name| at ($target_x|,$target_y|)." end
        else
          use_message = _"$actor_name| ($actor.x|,$actor.y|) $uses| $action.name|."
        end
      end
      EoHS.action_message(parameters, use_message, extra_values)
    end
  end)
  
  -- Make the caster visible for sides who can see
  if w111 then
    local sides_list = {}
    for side,can in ipairs(sides_who_can_see_action) do if can then table.insert(sides_list,side) end end
    wesnoth.fire("lift_fog", {
      x = actor.x, y = actor.y,
      { "filter_side", { side=table.concat(sides_list,",") } },
    })
  else
    -- In 1.10, we can't clear just a single hex.
    -- Instead, clear as little as possible: that hex plus every adjacent hex.
    -- Nixed because it caused unavoidable graphical glitches in *normal* situations (unit ellipse cycles color oddly),
    -- while the alternative is to cause glitches in *strange* situations (e.g. getting fireballed from fog)
    --[[
    local old_max_moves = actor.max_moves
    actor.max_moves = 0
    EoHS.put_unit(actor, {immediate=true})
    local wunit = wesnoth.get_unit(actor.x,actor.y)
    for side,can in ipairs(sides_who_can_see_action) do
      if can and (side ~= actor.side) then
        wunit.side = side
        wesnoth.fire("redraw",{clear_shroud=true,side=side})
      end
    end
    actor.max_moves = old_max_moves
    EoHS.put_unit(actor, {immediate=true})]]
  end
  
  local extras = {
    do_on_clients_who_see = function(func) EoHS.disunified(function() if local_client_can_see then func() end end) end,
    cost_paid = cost,
  }
  
  EoHS.disunified(function() if local_client_can_see then EoHS.lock_view()   end end)
  EoHS.during_action = true
  EoHS.actions[parameters.action_id].happen(parameters, extras)
  EoHS.during_action = nil -- TODO decide whether actions can be nested
  EoHS.disunified(function() if local_client_can_see then EoHS.unlock_view() end end)
end

EoHS.pay_action_cost = function(parameters, cost)
  if cost.gold then
    local actor = EoHS.get_unit(parameters.actor_id)
    wesnoth.sides[actor.side].gold = wesnoth.sides[actor.side].gold - cost.gold
  end
  if cost.mana then
    local mana_paid, gold_paid = EoHS.deduct_mana_andor_gold(parameters.actor_id, cost.mana)
    cost.mana = mana_paid
    cost.gold = (cost.gold or 0) + gold_paid
  end
  if cost.action_points then
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.set_unit_action_points_immediate(actor, EoHS.get_unit_action_points(actor) - cost.action_points)
    -- and if it uses action points then it's tiring
    EoHS.set_unit_attribute_immediate(actor, "resting", false)
  end
end

EoHS.attack_AP_cost = function(unit)
  return EoHS.get_unit_variable(unit, "is_lich") and 3 or 6
end

EoHS.get_unit_action_points = function(unit)
  return (EoHS.attack_AP_cost(unit)*unit.attacks_left) + (EoHS.get_unit_variable(unit, "extra_action_points") or 5)
end

EoHS.set_unit_action_points_immediate = function(unit, amount)
  local attack_AP_cost = EoHS.attack_AP_cost(unit)
  EoHS.set_unit_attribute_immediate(unit, "attacks_left", math.floor(amount / attack_AP_cost))
  EoHS.set_unit_variable_immediate(unit, "extra_action_points", amount % attack_AP_cost)
  EoHS.update_orb(unit)
end

EoHS.deduct_mana_andor_gold = function(unit_id, amount)
  local unit = EoHS.get_unit(unit_id)
  local mana = EoHS.get_unit_variable(unit, "mana")
  if mana <= 0 then
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold - amount
    return 0, amount
  elseif mana < amount then
    EoHS.set_unit_variable_immediate(unit, "mana", 0)
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold + mana - amount
    return mana, amount - mana
  else
    EoHS.set_unit_variable_immediate(unit, "mana", mana - amount)
    return amount, 0
  end
end

EoHS.unit_mana_income = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    return EoHS.get_wizard_setting(unit, "mana_income_at_level_0") + 
           EoHS.get_wizard_setting(unit, "mana_income_per_level")*unit.level +
           (EoHS.get_unit_variable(unit, "soul_bind_mana_income") or 0)
  end
  if EoHS.get_unit_variable(unit, "is_summon") then
    if unit.type == "Fire Dragon" then return 2*unit.level end
  end
end
EoHS.unit_mana_cap = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    local setting = EoHS.get_wizard_setting(unit, "mana_capacity_per_level")
    if setting == "infinite" then return nil end
    return setting*unit.level
  end
end
EoHS.earn_mana = function(unit, amount)
  local mcap = EoHS.unit_mana_cap(unit)
  local old_mana = EoHS.get_unit_variable(unit, "mana")
  if (not mcap) or (old_mana < mcap) then
    local new_mana = old_mana + amount
    if mcap and (new_mana > mcap) then
      new_mana = mcap
    end
    EoHS.set_unit_variable_immediate(unit, "mana", new_mana)
  end
end
EoHS.earn_mana_income = function(unit)
  if wesnoth.current.turn > 1 then -- parallel to built-in rule about gold income
    local mincome = EoHS.unit_mana_income(unit)
    if mincome and (mincome > 0) then
      EoHS.earn_mana(unit, mincome)
    end
  end
end

EoHS.action_cost = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local cost
  if type(action.base_cost) == "function" then
    cost = action.base_cost(parameters)
  else
    cost = EoHS.deep_copy(action.base_cost)
  end
  cost = cost or {}
  
  local actor = EoHS.get_unit(parameters.actor_id)
  if actor and action.is_summon then
    if cost.action_points and EoHS.get_unit_skill(actor, "summoner") and not action.is_ritual then
      cost.action_points = cost.action_points - 2
    end
    local multiplier = EoHS.get_wizard_setting(actor, "summon_cost_multiplier")
    if cost.mana and multiplier then
      cost.mana = math.ceil(cost.mana * multiplier / 100)
    end
  end
  if cost.mana and action.is_spell and EoHS.get_unit_skill(actor, "efficiency") then
    cost.mana = math.floor(0.5 + cost.mana*0.8)
  end
  if cost.action_points and EoHS.get_unit_skill(actor, "enchanter") and action.is_enchantment then
    cost.action_points = cost.action_points - 2
  end
  return cost
end

EoHS.action_range = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local range
  if type(action.base_range) == "function" then
    range = action.base_range(parameters)
  else
    range = action.base_range
  end
  if not range then return nil end
  
  local actor = EoHS.get_unit(parameters.actor_id)
  if action.is_spell and EoHS.get_unit_skill(actor, "farseer") then
    range = range * 2
  end
  return range
end

EoHS.target_types = {
  hex = function(parameters) return {
    short_name = _"hex",
    name = _"Any hex",
    details = "",
    -- Not a side-specific check - we'll deal with that elsewhere, not in the target type
    validity = EoHS.location_is_passable(parameters.target_x, parameters.target_y) and "valid" or "impossible"
  } end,
  empty_hex = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    return {
      short_name = _"empty hex",
      name = _"Empty hex",
      details = ((not unfogged) and _"You can't tell if that hex is occupied." or ""),
      validity = (unfogged and not unit) and "valid" or "impossible"
    }
  end,
  recruit = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local keep = wesnoth.get_terrain_info(wesnoth.get_terrain(actor.x, actor.y)).keep
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local path = EoHS.find_path(actor.x,actor.y,parameters.target_x,parameters.target_y,function(x,y) return wesnoth.get_terrain_info(wesnoth.get_terrain(x, y)).castle and 1 or nil end)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    -- Intentionally allowing impassable
    return {
      short_name = _"recruit hex",
      name = _"Recruit hex",
      details = ((not unfogged) and _"You can't tell if that hex is occupied." or ""),
      validity = (keep and path[1] and unfogged and not unit) and "valid" or "impossible"
    }
  end,
  unit = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    return {
      short_name = _"unit",
      name = _"Any unit",
      details = ((not unfogged) and _"You can't tell if there is a unit there." or ""),
      validity = (unit and unfogged) and "valid" or "impossible"
    }
  end,
  unit_probably_enemy = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    local is_enemy = unit and wesnoth.is_enemy(unit.side, actor.side)
    return {
      short_name = _"unit",
      name = _"Unit (probably enemy)",
      details = ((not unfogged) and _"You can't tell if there is a unit there." or ((unit and not is_enemy) and _"You probably don't want to cast that at an ally." or "")),
      validity = ((unit and unfogged)
        and (is_enemy and "valid" or "undesirable")
        or "impossible")
    }
  end,
  unit_probably_ally = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    local unit = EoHS.get_seen_unit(parameters.target_x,parameters.target_y,actor.side)
    local unfogged = EoHS.hex_is_unfogged(parameters.target_x,parameters.target_y)
    local is_enemy = unit and wesnoth.is_enemy(unit.side, actor.side)
    return {
      short_name = _"unit",
      name = _"Unit (probably ally)",
      details = ((not unfogged) and _"You can't tell if there is a unit there." or ((unit and is_enemy) and _"You probably don't want to cast that at an enemy." or "")),
      validity = ((unit and unfogged)
        and (is_enemy and "undesirable" or "valid")
        or "impossible")
    }
  end,
}

EoHS.action_message = function(parameters, string, extra_values)
  local values = EoHS.deep_copy(parameters)
  if extra_values then for k,v in pairs(extra_values) do values[k] = v end end
  local action = EoHS.actions[parameters.action_id]
  values.action = {}
  for k,v in pairs(action) do
    if (type(k) == "string") and (type(v) ~= "function") and (type(v) ~= "table") then values.action[k] = v end
  end
  if parameters.actor_id then
    values.actor = EoHS.get_unit(parameters.actor_id)
    if values.actor then values.actor_name = EoHS.unit_appellation(values.actor) end
  end
  if parameters.target_x then
    values.target = EoHS.get_unit(parameters.target_x, parameters.target_y)
    if values.target then values.target_name = EoHS.unit_appellation(values.target) end
  end
  values.uses = _"uses"
  if action.is_spell then values.uses = _"casts" end
  if action.is_ritual then values.uses = _"starts casting" end
  EoHS.message(EoHS.substitute(string, values))
end

EoHS.begin_casting = function(actor_id, target_x, target_y)
  local actor = EoHS.get_unit(actor_id)
  wesnoth.scroll_to_tile(actor.x, actor.y, true)

  if target_x then
    EoHS.face_towards(actor, target_x, target_y)
  end

  EoHS.set_unit_attribute_immediate(actor, "facing", actor.facing)
  wesnoth.fire("redraw")
  EoHS.set_unit_variable_immediate(actor, "is_casting_a_spell", true)
  EoHS.animate_unit({
    flag = "EoHS_start_casting",
    with_bars = true,
    { "filter", { x=actor.x, y=actor.y, }},
  }, {dont_redraw_first=true})
  if target_x then
    wesnoth.scroll_to_tile(target_x, target_y, true)
  end
end

EoHS.finish_casting = function(actor_id)
  local actor = EoHS.get_unit(actor_id)
  -- In rare cases, the spell might have killed the caster, so only proceed if they can be found:
  if actor then
    wesnoth.fire("redraw")
    EoHS.set_unit_variable_immediate(actor, "is_casting_a_spell")
    EoHS.animate_unit({
      flag = "EoHS_stop_casting",
      with_bars = true,
      { "filter", { x=actor.x, y=actor.y, }},
    }, {dont_redraw_first=true})
  end
end

EoHS.actions = {}
EoHS.make_action = function(id, action)
  if (type(action.image) ~= "string") or not (string.match(action.image, "attacks/") or string.match(action.image, "icons/")) then
    action.image = EoHS.collapse_image_aggregate("image_modded", EoHS.image_aggregates_combined(
      "attacks/blank-attack.png",
      EoHS.image_aggregate_cropped(action.image, {size={x=50,y=50},offset={x=0,y=0}})
    ))
  end
  action.id = id
  EoHS.actions[id] = action
end

EoHS.make_spell = function(id, action)
  action.is_spell = true
  EoHS.make_action(id, action)
end

EoHS.make_touch_enchantment = function(id, action)
  action.is_enchantment = true
  if not action.affected_hexes then action.affected_hexes = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    return {{x=actor.x,y=actor.y,visual="help"}}
  end end
  if not action.make_extra_attributes then action.make_extra_attributes = function(parameters, make_aspect)
    local actor = EoHS.get_unit(parameters.actor_id)
    local touch_enchantment = EoHS.get_unit_variable(actor, "touch_enchantment")
    local details = ""
    local validity = "valid"
    if touch_enchantment == id then
      validity = "impossible"
      details = _"You already have that spell active."
    elseif touch_enchantment then
      validity = "undesirable"
      details = _"Replaces your current touch enchantment"
    end
      
    make_aspect.type_and_details(_"Touch enchantment", details, validity)
  end end
  if not action.happen then action.happen = function(parameters, extras)
    EoHS.begin_casting(parameters.actor_id)
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.set_unit_variable(actor, "touch_enchantment", id)
    EoHS.update_all_type_adjustments(actor)
    if action.sound then extras.do_on_clients_who_see(function() wesnoth.fire("sound", { name = action.sound }) end) end
    EoHS.put_unit(actor, {immediate=true})
    EoHS.finish_casting(parameters.actor_id)
  end end
  
  EoHS.make_spell(id, action)
end

local ritual_desc = _"This spell takes $1| turns (counting the turn you start it), and takes effect at the beginning of its last turn. Once you start casting this spell, you cannot move, attack, or cast other spells, or earn mana until after its last turn (or the turn when you cancel it)."
EoHS.make_ritual = function(id, action)
  local ritual_turns = function(parameters)
    local result = action.turns
    local actor = EoHS.get_unit(parameters.actor_id)
    if action.is_summon and EoHS.get_unit_skill(actor, "summoner") then
      result = result - 1
    end
    return result
  end
  
  action.is_ritual = true
  
  if type(action.base_cost) == "table" then action.base_cost.action_points = 11
  elseif type(action.base_cost) == "function" then 
    local old_func = action.base_cost
    action.base_cost = function(parameters)
      local result = old_func(parameters)
      result.action_points = 11
      return result
    end
  else
    action.base_cost = { action_points = 11 }
  end
    
  local old_make_extra_attributes = action.make_extra_attributes
  action.make_extra_attributes = function(parameters, make_aspect)
    local turns = ritual_turns(parameters)
    make_aspect.type_value_and_details(_"Ritual:", EoHS.substitute(_"$1| turns", {turns}), EoHS.substitute(ritual_desc, {turns}))
    if old_make_extra_attributes then old_make_extra_attributes(parameters, make_aspect) end
  end
  action.happen = function(parameters)
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.begin_casting(parameters.actor_id, parameters.target_x, parameters.target_y)
    EoHS.set_unit_variable(actor, "ritual", id)
    EoHS.set_unit_variable(actor, "ritual_runes", ritual_turns(parameters))
    EoHS.set_unit_variable(actor, "ritual_runes_lit", 1)
    local ritual_parameters = EoHS.get_fake_subtag(EoHS.force_unit_variables(actor), "ritual_parameters")
    for k,v in pairs(parameters) do ritual_parameters[k] = v end -- TODO can we rely on this making a valid WML table?
    actor.moves = 0
    EoHS.set_unit_action_points_immediate(actor, 0)
    EoHS.update_all_type_adjustments(actor)
    EoHS.put_unit(actor)
  end
  
  EoHS.make_spell(id, action)
end

EoHS.soon(function()
  EoHS.make_action("cancel_ritual", {
    image = "scenery/tent-ruin-1.png",
    name = _"Cancel Ritual",
    description = _"You abandon your current ritual. You don't recover any of the cost, and you still can't move this turn, but you'll be able to move next turn.",
    
    affected_hexes = function(parameters)
      local actor = EoHS.get_unit(parameters.actor_id)
      return {{x=actor.x,y=actor.y,visual="change"}}
    end,
    
    use_message = function(parameters)
      local actor = EoHS.get_unit(parameters.actor_id)
      return _"$actor_name| ($actor.x|,$actor.y|) stops casting $ritual|.", {ritual=EoHS.actions[EoHS.get_unit_variable(actor, "ritual")].name}
    end,
    
    happen = function(parameters)
      local actor = EoHS.get_unit(parameters.actor_id)
      EoHS.set_unit_variable(actor, "ritual")
      EoHS.update_all_type_adjustments(actor)
      EoHS.put_unit(actor)
      EoHS.finish_casting(parameters.actor_id)
    end,
  })
end)

EoHS.skill_attack_func = function(realm, func)
  return function(actor)
    for attack in helper.child_range(actor, "attack") do
      if attack.name == "EoHS_"..realm.."_skill_ranged_attack" then
        local result = EoHS.deep_copy(attack)
        EoHS.remove_subtags(result, "specials.*", "EoHS_lightning_paralysis")
        EoHS.remove_subtags(result, "specials.*", "EoHS_just_teleported_1")
        EoHS.remove_subtags(result, "specials.*", "EoHS_just_teleported_2")
        func(result)
        return result
      end
    end
  end
end

-->>)}
