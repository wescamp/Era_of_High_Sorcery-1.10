this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- game_action_simulations.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

--[[

combatant = { unit=,weapon_index_zero_based= number, -1 for no attack, or "choose" }
attack_context = {
  attacker = combatant
  defender = combatant
}

]]

EoHS.game_action_simulations = {
  advance_unit_internal = function(unit, advance_to) -- unit get_advanced_unit(const unit &u, const std::string& advance_to) {
    if type(advance_to) == "table" then
      table.insert(EoHS.force_subtag(unit, "modifications"), {"advance",advance_to})
      advance_to = unit.type
    end
   
    if not wesnoth.unit_types[advance_to] then                            -- const unit_type *new_type = unit_types.find(advance_to); if (!new_type) {
      EoHS.err("Could not find the unit being advanced to: "..advance_to) -- throw game::game_error("Could not find the unit being advanced" " to: " + advance_to);
    end                                                                   -- }
                                                               -- unit new_unit(u); 
    unit.experience = unit.experience - unit.max_experience    -- new_unit.set_experience(new_unit.experience() - new_unit.max_experience());
   
    EoHS.transform_unit(unit, advance_to)                      -- new_unit.advance_to(new_type);
    unit.hitpoints = unit.max_hitpoints
    EoHS.set_subtag_attribute(unit, "status.poisoned" , false) -- new_unit.set_state(unit::STATE_POISONED, false);
    EoHS.set_subtag_attribute(unit, "status.slowed"   , false) -- new_unit.set_state(unit::STATE_SLOWED, false);
    EoHS.set_subtag_attribute(unit, "status.petrified", false) -- new_unit.set_state(unit::STATE_PETRIFIED, false);
                                                               -- new_unit.set_user_end_turn(false);
    EoHS.set_subtag_attribute(unit, "status.uncovered", true ) -- new_unit.set_hidden(false);
                                                               -- return new_unit; }
  end,
  
  advance_unit_on_map = function(x, y, advance_to, animate, fire_event)
    EoHS.assert(EoHS.location_is_on_the_map(x,y,true), "EoHS.game_action_simulations.advance_unit_on_map with off-map unit")
    local unit = EoHS.get_unit(x, y)
    EoHS.assert(unit, "EoHS.game_action_simulations.advance_unit_on_map no unit")
    EoHS.assert(unit.experience >= unit.max_experience, "EoHS.game_action_simulations.advance_unit_on_map with unit that shouldn't advance")
    
    if not advance_to then return end
    
    if animate then
      wesnoth.fire("animate_unit", {
        { "filter", { x=x, y=y }},
        flag="levelout"
      })
    end
    
    if fire_event then
      local original_type = unit.type
      EoHS.fire_event("advance", x, y)
      -- Note: In 1.10.7 there appears to be a bug where AMLA (and only AMLA) overwrites the results of an advance event.
      -- I have no desire to faithfully replicate this bug, since no scenario should rightly rely on it.
      unit = EoHS.get_unit(x, y)
      if not (unit and (unit.experience >= unit.max_experience) and (unit.type == original_type)) then return end
    end
    
    EoHS.game_action_simulations.advance_unit_internal(unit, advance_to)
    EoHS.put_unit(unit)
    
    if fire_event then
      EoHS.fire_event("post_advance", x, y)
      unit = EoHS.get_unit(x, y)
      if not unit then return end
    end
    
    if animate then
      wesnoth.fire("animate_unit", {
        { "filter", { x=x, y=y }},
        flag="levelin"
      })
    end
  end,
  
  choose_advancement = function(unit)

local g = function(contents) return { "grid", contents } end
local r = function(contents) return { "row", contents } end
local c = function(contents) return { "column", contents } end
    local valid_advance_tos = {}
    if type(unit.advances_to) == "string" then
      for a in EoHS.comma_separated_values(unit.advances_to) do
        if wesnoth.unit_types[a] then table.insert(valid_advance_tos, a) end
      end
    end
    local advance_id_counts = {}
    for i,a in ipairs(EoHS.get_subtags(unit, "modifications.advance")) do
      local id = a[2].id
      if id then
        advance_id_counts[id] = (advance_id_counts[id] or 0) + 1
      end
    end
    local any_types = valid_advance_tos[1]
    local force_display
    for advancement in helper.child_range(unit, "advancement") do
      if not (advancement.strict_amla and any_types) then
        local max_times = advancement.max_times or 1
        if (not advancement.id) or (max_times < 0) or ((advance_id_counts[advancement.id] or 0) < max_times) then
          local meets_reqs = true
          local reqs = {}
          if advancement.require_amla then
            for aid in EoHS.comma_separated_values(advancement.require_amla) do
              reqs[aid] = (reqs[aid] or 0) + 1
            end
          end
          for k,v in pairs(reqs) do
            if not (advance_id_counts[k] and (advance_id_counts[k] >= v)) then meets_reqs = false end
          end
          if meets_reqs then
            table.insert(valid_advance_tos, advancement)
            if advancement.always_display then force_display = true end
          end
        end
      end
    end
    local selected_idx = 1
    if force_display or valid_advance_tos[2] then
      if unit.side == wesnoth.current.side then -- TODO: "or this is a one player game"
        selected_idx = EoHS.synchronize_choice(function()
          local done = false
          local current_prototype
          while not done do
            local dialog_context = EoHS.make_dialog_context(function() done=true end, function() end)
            local rows = { r{c{ horizontal_alignment="left", {"label",{ label=_"What should our victorious unit become?" }} }} }
            for i,valid_advance_to in ipairs(valid_advance_tos) do
              -- TODO reduce duplicate code with train_apprentice
              local prototype = EoHS.deep_copy(unit)
              EoHS.game_action_simulations.advance_unit_internal(prototype, valid_advance_to)
              EoHS.standardize_unit(prototype) -- TODO evaluate whether this is the right way to do this
              if i == selected_idx then current_prototype = prototype end
              local label = prototype.language_name
              if type(valid_advance_to) == "table" then label = valid_advance_to.description end
              local image = EoHS.unit_thumbnail(prototype, true)
              table.insert(rows, r{c{ horizontal_grow=true, EoHS.fake_listbox_entry(dialog_context, "m\nm\nm\nm\nmmmmmm"..label, {
              {"image",{
                x = 0,
                y = "((height/2)-(image_height/2))",
                w = "(if(height<72,height,72))",
                h = "(if(height<72,height,72))",
                name = image
              }},
              {"text",{
                x=72,
                y=EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED,
                w="(text_width)",
                h="(text_height)",
                font_size = EoHS.macros.GUI_NORMAL__FONT_SIZE__SMALL,
                color = EoHS.macros.GUI__FONT_COLOR_ENABLED__DEFAULT,
                text = label
              }} }, i == selected_idx, function() selected_idx = i end) }})
            end
            -- TODO proper textdomains
            dialog_context.show(g{r{c{ horizontal_alignment="left", {"label",{definition="title",label=_"Advance Unit"}} }},
              r{c{g{r{
              c{vertical_alignment="top",EoHS.unit_preview_pane(dialog_context, current_prototype)},
              c{vertical_alignment="top",g(rows)},  
            }}}},
            r{c{ horizontal_alignment="right", {"button",{ label=_"OK", id="ok" }} }}
            })
          end
          return {result = selected_idx}
        end).result
      else
        selected_idx = EoHS.random("1.."..#valid_advance_tos)
      end
    end
    return valid_advance_tos[selected_idx]
  end,
  
  attack_matches_filter = function(attack, filter)
    if not attack then return false end
    -- TODO 1.11: special
    if filter.name   and (attack.name   ~= filter.name  ) then return false end
    if filter.type   and (attack.type   ~= filter.type  ) then return false end
    if filter.range  and (attack.range  ~= filter.range ) then return false end
    if filter.damage and (attack.damage ~= filter.damage) then return false end
    return true
  end,
  
  special_active = function(combatant, special)
    if (combatant.role == "attacker") and (special.active_on == "defense") then return false end
    if (combatant.role == "defender") and (special.active_on == "offense") then return false end
    local filter_combatant = function(c, fname)
      local filter = EoHS.get_subtag(special, fname)
      if filter then
        if not wesnoth.match_unit(c.wunit, filter) then return false end
        local filter_weapon = EoHS.get_subtag(filter, "filter_weapon")
        if filter_weapon and not EoHS.game_action_simulations.attack_matches_filter(c.attack, filter_weapon) then return false end
      end
      return true
    end
    if not filter_combatant(combatant         , "filter_self"    ) then return false end
    if not filter_combatant(combatant.opponent, "filter_opponent") then return false end
    local attacker = (combatant.role == "attacker") and combatant or combatant.opponent
    if not filter_combatant(attacker          , "filter_attacker") then return false end
    local defender = (combatant.role == "defender") and combatant or combatant.opponent
    if not filter_combatant(defender          , "filter_defender") then return false end
    
    for filter_adjacent in helper.child_range(special, "filter_adjacent") do
      for dir in EoHS.comma_separated_values(filter_adjacent.adjacent) do
        local adj_wunit = wesnoth.get_unit(EoHS.get_loc_in_direction(combatant.x, combatant.y, dir))
        if not adj_wunit then return false end
        if not wesnoth.match_unit(adj_wunit, filter_adjacent) then return false end
      end
    end
    for filter_adjacent_location in helper.child_range(special, "filter_adjacent_location") do
      for dir in EoHS.comma_separated_values(filter_adjacent_location.adjacent) do
        if not wesnoth.match_location(EoHS.get_loc_in_direction(combatant.x, combatant.y, dir), filter_adjacent_location) then return false end
      end
    end

    return true
  end,
  
  special_affects_self = function(combatant, special)
    local a = special.apply_to or "self"
    return (a == "self") or (a == "both") or (a == combatant.role)
  end,
  special_affects_opponent = function(combatant, special)
    local a = special.apply_to or "self"
    return (a == "opponent") or (a == "both") or (a == combatant.opponent.role)
  end,
  
  ability_active = function(wunit, ability)
    local filter = EoHS.get_subtag(ability, "filter")
    if filter and not wesnoth.match_unit(wunit, filter) then return false end
    
    -- Replicating undocumented behavior of filter_adjacent and filter_adjacent_location
    -- working as in weapon specials. TODO ask devs and document on wiki
    for filter_adjacent in helper.child_range(ability, "filter_adjacent") do
      for dir in EoHS.comma_separated_values(filter_adjacent.adjacent) do
        local adj_wunit = wesnoth.get_unit(EoHS.get_loc_in_direction(wunit.x, wunit.y, dir))
        if not adj_wunit then return false end
        if not wesnoth.match_unit(adj_wunit, filter_adjacent) then return false end
      end
    end
    for filter_adjacent_location in helper.child_range(ability, "filter_adjacent_location") do
      for dir in EoHS.comma_separated_values(filter_adjacent_location.adjacent) do
        if not wesnoth.match_location(EoHS.get_loc_in_direction(wunit.x, wunit.y, dir), filter_adjacent_location) then return false end
      end
    end

    return true
  end,
  
  ability_affects_adjacent = function(wunit, able_unit, ability)
    if not ability[wesnoth.is_enemy(wunit.side, able_unit.side) and "affect_enemies" or "affect_allies"] then return false end
    for affect_adjacent in helper.child_range(ability, "affect_adjacent") do
      for dir in EoHS.comma_separated_values(affect_adjacent.adjacent) do
        local x,y = wesnoth.get_unit(EoHS.get_loc_in_direction(able_unit.x, able_unit.y, dir))
        if (x==wunit.x) and (y==wunit.y) then
          local filter = EoHS.get_subtag(affect_adjacent, "filter")
          if (not filter) or wesnoth.match_unit(wunit, filter) then return true end
        end
      end
    end

    return false
  end,

  ability_affects_self = function(wunit, ability)
    if not ability.affect_self then return false end
    local filter = EoHS.get_subtag(ability, "filter_self")
    if (not filter) or wesnoth.match_unit(wunit, filter) then return true end
    return false
  end,

  abilities_affecting_unit_wunit = function(unit, wunit)
    local result = {}
    local abilities = EoHS.get_subtag(unit, "abilities")
    if abilities then for i,ability in ipairs(abilities) do
      if EoHS.game_action_simulations.ability_active(wunit, ability[2]) and EoHS.game_action_simulations.ability_affects_self(wunit, ability[2]) then
        table.insert(result, ability)
      end
    end end
    for x,y in helper.adjacent_tiles(unit.x,unit.y) do
      local aunit = EoHS.get_unit(x,y)
      if aunit then
        local awunit = wesnoth.get_unit(x,y)
        local aabilities = EoHS.get_subtag(aunit, "abilities")
        if aabilities then for i,ability in ipairs(aabilities) do
          if EoHS.game_action_simulations.ability_affects_adjacent(wunit, aunit, ability[2]) and EoHS.game_action_simulations.ability_active(awunit, ability[2]) then
            table.insert(result, ability)
          end
        end end
      end
    end
    return result
  end,
  
  unit_wunit_is_hidden = function(unit, wunit, viewing_side)
    if viewing_side and not wesnoth.is_enemy(unit.side, viewing_side) then return false end
    if EoHS.get_subtag_attribute(unit, "status.uncovered") then return false end
    for x,y in helper.adjacent_tiles(unit.x,unit.y) do
      local aunit = EoHS.get_unit(x,y)
      if aunit and wesnoth.is_enemy(unit.side, aunit.side) then return false end
    end
    for i,ability in ipairs(EoHS.game_action_simulations.abilities_affecting_unit_wunit(unit, wunit)) do
      if ability[1] == "hides" then return true end
    end
    return false
  end,
  
  backstab_check = function(a,d)
    local ox,oy = EoHS.same_relative_location(d.x,d.y,a.x,a.y,d.x,d.y)
    local o = wesnoth.get_unit(ox,oy)
    if o and wesnoth.is_enemy(d.side, o.side) then return true end
    return false
  end,
  
  -- TODO update this to use simulate_combat in 1.11
  fleshed_out_attack_context = function(attack_context, options)
    -- TODO evaluate best copying rules
    -- local result = {attacker=EoHS.shallow_copy(attack_context.attacker),defender=EoHS.shallow_copy(attack_context.defender)}
    local result = EoHS.deep_copy(attack_context)
    
    result.attacker.role = "attacker"
    result.defender.role = "defender"
    result.attacker.opponent = result.defender
    result.defender.opponent = result.attacker
    result[1] = result.attacker
    result[2] = result.defender
    for i,combatant in ipairs(result) do
      if combatant.unit then
        combatant.x = combatant.unit.x
        combatant.y = combatant.unit.y
      end
      local map_unit = EoHS.get_unit(combatant.x, combatant.y)
      if not combatant.unit then
        combatant.unit = map_unit
        combatant.wunit = wesnoth.get_unit(combatant.x, combatant.y)
      end
      if not combatant.unit then
        return nil
      end
      if EoHS.get_subtag_attribute(combatant.unit, "status.petrified") then return nil end
      combatant.on_map = map_unit and (map_unit.underlying_id == combatant.unit.underlying_id)
      if not combatant.wunit then combatant.wunit = EoHS.create_wunit(combatant.unit) end
      combatant.not_living = EoHS.get_subtag_attribute(combatant.unit, "status.not_living")
      if not combatant.terrain      then combatant.terrain = wesnoth.get_terrain(combatant.unit.x, combatant.unit.y) end
      if not combatant.lawful_bonus then combatant.lawful_bonus = EoHS.get_time_of_day(combatant.x, combatant.y).lawful_bonus end
      if combatant.attack and not (combatant.attack.damage and combatant.attack.number) then combatant.attack = nil end
      if combatant.weapon_index_zero_based == "choose" then
      -- Can I replicate the complex rules about choosing defender weapons?
      -- You know what, I just don't care.
        local attack_counter = 0
        local choice
        local best_goodness
        for i,attack in ipairs(EoHS.get_subtags(combatant.unit, "attack")) do
          -- Hack - assume only defender can be "choose" and that the attacker's stuff has already been found
          if (attack.range == combatant.opponent.attack.range) and ((tonumber(attack.defense_weight) or 1) > 0) then
            local goodness
            if combatant.on_map then
              local att_stats,def_stats = wesnoth.simulate_combat(combatant.opponent.wunit, combatant.opponent.weapon_index_zero_based+1, combatant.wunit, attack_counter+1)
              goodness = (
                (att_stats.hp_chance[0] - def_stats.hp_chance[0])*100*(combatant.unit.max_hitpoints+combatant.opponent.unit.max_hitpoints)
                + (att_stats.poisoned*wesnoth.game_config.poison_amount-att_stats.average_hp)
                - (def_stats.poisoned*wesnoth.game_config.poison_amount-def_stats.average_hp)
                )
            else
              -- TODO: Any problem if we temporarily put it on the map so the behavior is the same?
              local try_attack_context = EoHS.deep_copy(attack_context)
              try_attack_context.defender.weapon_index_zero_based = attack_counter
              try_attack_context = EoHS.game_action_simulations.fleshed_out_attack_context(try_attack_context)
              goodness = ((try_attack_context.defender.attacks * try_attack_context.defender.attacks * try_attack_context.defender.damage) +
                (try_attack_context.defender.slows   and (not EoHS.get_subtag_attribute(combatant.opponent.unit, "status.slowed"  )) and 20 or 0) + 
                (try_attack_context.defender.poisons and (not EoHS.get_subtag_attribute(combatant.opponent.unit, "status.poisoned")) and 8 or 0))
            end
            if (not choice) or (goodness > best_goodness) then
              choice = attack_counter
              best_goodness = goodness
            end
          end
          attack_counter = attack_counter + 1
        end
        combatant.weapon_index_zero_based = choice
      end
      if type(combatant.weapon_index_zero_based) == "number" then
        local attack_counter = combatant.weapon_index_zero_based
        for i,attack in ipairs(EoHS.get_subtags(combatant.unit, "attack")) do
          attack_counter = attack_counter - 1
          if attack_counter < 0 then
            combatant.attack = attack
            break
          end
        end
      end
      if combatant.attack then
        combatant.all_owned_specials = EoHS.get_subtag(combatant.attack, "specials")
        if type(combatant.weapon_index_zero_based) ~= "number" then
          local attack_counter = 0
          for i,attack in ipairs(EoHS.get_subtags(combatant.unit, "attack")) do
            if attack.name == combatant.attack.name then
              combatant.weapon_index_zero_based = attack_counter
              break
            end
            attack_counter = attack_counter + 1
          end
        end
      end
      if (combatant.role == "attacker") and not combatant.attack then
        return nil
      end
    end
    for i,combatant in ipairs(result) do
      if combatant.attack then
        combatant.active_specials = {}
        combatant.backstab = (combatant.role == "attacker") and EoHS.game_action_simulations.backstab_check(combatant.unit, combatant.opponent.unit)
        local special_infos = { attacks = {def=combatant.attack.number}, damage = {def=combatant.attack.damage}, chance_to_hit = {def=wesnoth.unit_defense(combatant.opponent.wunit, combatant.opponent.terrain)} }
        local handle_special = function(special)
          if special.backstab and not combatant.backstab then return end -- if (!backstab && cfg["backstab"].to_bool()) continue; -- TODO should we consider backstab in the activity checks?
          --  if (!filter_base_matches(cfg, def)) continue; -- TODO
          table.insert(combatant.active_specials, special)
          local info = special_infos[special[1]]
          if not info then info = {}; special_infos[special[1]] = info end
          if not info.add then info.add=0 end
          if not info.multiply then info.multiply=1 end
                      
          if special[2].value then -- if (const config::attribute_value *v = cfg.get("value")) { int value = *v; bool cumulative = cfg["cumulative"].to_bool();
            if (not info.value_set) and not special[2].cumulative then         -- if (!value_is_set && !cumulative) {
              info.value_set = special[2].value -- value_set = value; set_effect.set(SET, value, i->first, i->second);
            else            -- } else {
              if special[2].cumulative then info.value_set = math.max(info.value_set or info.def, info.def) end  -- if (cumulative) value_set = std::max<int>(value_set, def);
              if special[2].value > info.value_set then info.value_set = special[2].value end          --if (value > value_set) { value_set = value; set_effect.set(SET, value, i->first, i->second); }
            end        -- } value_is_set = true;
          end -- }
          if special[2].add then
            info.add = info.add + special[2].add
          end
          if special[2].sub then
            info.add = info.add - special[2].sub
          end
          if special[2].multiply then
            info.multiply = info.multiply * special[2].multiply
          end
          if special[2].divide then
            info.multiply = info.multiply / special[2].divide
          end
          if special[2].swarm_attacks_min then info.swarm_attacks_min = math.max(info.swarm_attacks_min or -math.huge, special[2].swarm_attacks_min) end
          if special[2].swarm_attacks_max then info.swarm_attacks_max = math.max(info.swarm_attacks_max or -math.huge, special[2].swarm_attacks_max) end
          if special[1] == "plague" then combatant.plague_type = special[2].type end
        end
        
        if combatant.         all_owned_specials then for i,special in ipairs(combatant.         all_owned_specials) do
          if (not (options and options.ignore_specials and special[2].id and options.ignore_specials[special[2].id])) and
             EoHS.game_action_simulations.special_active          (combatant, special[2])          and
             EoHS.game_action_simulations.special_affects_self    (combatant, special[2])          then handle_special(special) end
        end end
        if combatant.opponent.all_owned_specials then for i,special in ipairs(combatant.opponent.all_owned_specials) do
          if (not (options and options.ignore_specials and special[2].id and options.ignore_specials[special[2].id])) and
             EoHS.game_action_simulations.special_active          (combatant.opponent, special[2]) and
             EoHS.game_action_simulations.special_affects_opponent(combatant.opponent, special[2]) then handle_special(special) end
        end end
        
        combatant.slows        = special_infos.slow        and true or false
        combatant.petrifies    = special_infos.petrifies   and true or false
        combatant.firststrike  = special_infos.firststrike and true or false
        combatant.drains       = special_infos.drains      and (not combatant.opponent.not_living) or false
        combatant.poisons      = special_infos.poison      and (not combatant.opponent.not_living) or false
        combatant.rounds       = (special_infos.berserk and special_infos.berserk.value_set) or 1
        combatant.plagues      = (combatant.plague_type and (not combatant.opponent.not_living) and (combatant.opponent.unit.undead_variation ~= "null") and
          not wesnoth.get_terrain_info(wesnoth.get_terrain(combatant.opponent.x, combatant.opponent.y)).village)
        
        -- Why do specials round down, given that alignment, resistances, and leadership round to nearest-favoring-original-value?
        local special_value = function(name) return math.floor(((special_infos[name].value_set or special_infos[name].def) + (special_infos[name].add or 0)) * (special_infos[name].multiply or 1)) end
        combatant.base_damage   = special_value("damage")
        combatant.chance_to_hit = special_value("chance_to_hit")
        if special_infos.swarm then
          combatant.attacks = math.floor((special_infos.swarm.swarm_attacks_min or 0) + ((special_infos.swarm.swarm_attacks_max or special_value("attacks")) - (special_infos.swarm.swarm_attacks_min or 0)) * combatant.unit.hitpoints / combatant.unit.max_hitpoints)
        else
          combatant.attacks = special_value("attacks")
        end
        
                -- // Get the damage multiplier applied to the base damage of the weapon.
        local damage_multiplier = 100        -- int damage_multiplier = 100;

        local tod_bonus = 0 -- // Time of day bonus.
        if combatant.unit.alignment == "chaotic" then tod_bonus = -combatant.lawful_bonus end
        if combatant.unit.alignment == "lawful"  then tod_bonus =  combatant.lawful_bonus end
        if combatant.unit.alignment == "liminal" then tod_bonus = -math.abs(combatant.lawful_bonus) end
        if tod_bonus < 0 and EoHS.is_fearless(combatant.unit) then tod_bonus = 0 end
        damage_multiplier = damage_multiplier + tod_bonus      -- damage_multiplier += combat_modifier(u_loc, u.alignment(), u.is_fearless());

                -- // Leadership bonus.
        local leader_bonus -- int leader_bonus = 0;
        for i,leadership_ability in ipairs(EoHS.get_subtags(EoHS.game_action_simulations.abilities_affecting_unit_wunit(combatant.unit, combatant.wunit), "leadership")) do -- if (under_leadership(units, pu_loc, &leader_bonus).valid())
          if (not leader_bonus) or (leadership_ability.value > leader_bonus) then leader_bonus = leadership_ability.value end
        end
        if leader_bonus then damage_multiplier = damage_multiplier + leader_bonus end --         damage_multiplier += leader_bonus;
               
                -- // Resistance modifier.
        if combatant.attack.type then
          -- damage_multiplier *= opp.damage_from(*weapon, !attacking, opp_loc);
          damage_multiplier = math.floor(damage_multiplier * wesnoth.unit_resistance(combatant.opponent.wunit, combatant.attack.type, (combatant.role ~= "attacker"), combatant.opponent.x, combatant.opponent.y))
        else
          damage_multiplier = damage_multiplier * 100
        end 

        local round_damage = function(base,mult,div)
          local unrounded = base * mult / div
          if unrounded < base then return math.max(1, math.floor(unrounded + 0.5))
          else                     return math.max(1, math.ceil (unrounded - 0.5)) end
        end
                -- // Compute both the normal and slowed damage. For the record,
                -- // drain = normal damage / 2 and slow_drain = slow_damage / 2.
        combatant.damage      = round_damage(combatant.base_damage, damage_multiplier, 10000) -- damage = round_damage(base_damage, damage_multiplier, 10000);
        combatant.slow_damage = round_damage(combatant.base_damage, damage_multiplier, 20000) -- slow_damage = round_damage(base_damage, damage_multiplier, 20000);
        combatant.slowed = EoHS.get_subtag_attribute(combatant.unit, "status.slowed")
        if combatant.slowed then combatant.damage = combatant.slow_damage end -- if (is_slowed) damage = slow_damage;
        combatant.next_drains_damage = math.min(math.floor(combatant.damage / 2), combatant.unit.max_hitpoints - combatant.unit.hitpoints, math.floor(combatant.opponent.unit.hitpoints / 2))
      end
    end
    return result
  end,

  --void attack_unit(const map_location &attacker, const map_location &defender,
  --        int attack_with, int defend_with, bool update_display)
  --{
  attack_unit = function(attack_context, extras)
    --attack dummy(attacker, defender, attack_with, defend_with, update_display);
    --attack::attack(const map_location &attacker, const map_location &defender,
    --            int attack_with,
    --            int defend_with,
    --            bool update_display) :
    --    bc_(0),
    --    a_stats_(0),
    --    d_stats_(0),
    --    abs_n_attack_(0),
    --    abs_n_defend_(0),
    --    update_att_fog_(false),
    --    update_def_fog_(false),
    --    update_minimap_(false),
    --    a_(attacker, attack_with, *resources::units),
    --    d_(defender, defend_with, *resources::units),
    --    units_(*resources::units),
    --    errbuf_(),
    --    update_display_(update_display),
    --    OOS_error_(false)
    --{
    --}
    --dummy.perform();
    --void attack::perform()
    --{
    --// Stop the user from issuing any commands while the units are fighting
    --const events::command_disabler disable_commands;

    --if(!a_.valid() || !d_.valid()) {
    --        return;
    --}
    EoHS.assert(not EoHS.game_action_simulations.current_attack_context, "EoHS attack simulations can't be nested")
    EoHS.game_action_simulations.current_attack_context = { simple=attack_context }
    local animate = not (extras and (extras.animate == false))
    local a,d = {},{}
    a.s = attack_context.attacker
    d.s = attack_context.defender
    local valid = true
    local load_ac = function()
      if extras and extras.update_context_func then extras.update_context_func(attack_context) end
      local next_context = EoHS.game_action_simulations.fleshed_out_attack_context(attack_context)
      if attack_context.defender.weapon_index_zero_based == "choose" then
        attack_context.defender.weapon_index_zero_based = next_context.defender.weapon_index_zero_based
      end
      if next_context and ((not a.f) or
             ((next_context.attacker.x == a.f.x) and (next_context.attacker.y == a.f.y) and (next_context.attacker.unit.underlying_id == a.f.unit.underlying_id)
          and (next_context.defender.x == d.f.x) and (next_context.defender.y == d.f.y) and (next_context.defender.unit.underlying_id == d.f.unit.underlying_id))) then
        local fleshed_out_attack_context = next_context
        EoHS.game_action_simulations.current_attack_context.fleshed_out = fleshed_out_attack_context
        a.f = fleshed_out_attack_context.attacker
        d.f = fleshed_out_attack_context.defender
        a.unit = a.s.unit or a.f.unit
        d.unit = d.s.unit or d.f.unit
      else
        valid = false
        a.unit = a.s.unit or EoHS.get_unit(a.s.x, a.s.y)
        d.unit = d.s.unit or EoHS.get_unit(d.s.x, d.s.y)
      end
    end
    local anim_round = 1
    local anim_rounds = {{}}
    if extras then extras.animation_rounds = anim_rounds end
    local record_units = function()
      table.insert(anim_rounds[anim_round], a.unit or {type="remove_unit", x=a.s.x, y=a.s.y})
      table.insert(anim_rounds[anim_round], d.unit or {type="remove_unit", x=d.s.x, y=d.s.y})
    end
    local fired_attack_end = false
    local fire_event = function(name, reversed)
      if name == "attack_end" then
        if fired_attack_end then EoHS.err("Firing attack end twice"); return end
        fired_attack_end = true
      end
      local first = reversed and d or a
      local second = reversed and a or d
      EoHS.fire_event(name, first.unit.x, first.unit.y, second.unit.x, second.unit.y, first.f.attack, second.f.attack)
      load_ac()
      record_units()
    end
    local float_label = function(x, y, str)
      local func = function() wesnoth.float_label(x, y, str) end
      if animate then func() end
      table.insert(anim_rounds[anim_round], func)
    end
    local do_animation = function(tables)
      for i,t in ipairs(tables) do
        table.insert(anim_rounds[anim_round], t)
      end
      if animate and tables[1] then
        local a = EoHS.deep_copy(tables[1])
        for i=2,#tables do
          table.insert(a, {"animate",tables[i]})
        end
        wesnoth.fire("animate_unit",a)
      end
      anim_round = anim_round + 1
      anim_rounds[anim_round] = {}
    end
    load_ac()
    if (not a.unit) or (not d.unit) then return end

    --// no attack weapon => stop here and don't attack
    if a.f.weapon_index_zero_based < 0 then --if (a_.weapon_ < 0) {
      if not (extras and (extras.spend_moves_and_attacks == false)) then
        EoHS.set_unit_attribute_immediate(a.unit, "attacks_left", a.unit.attacks_left - 1) --a_.get_unit().set_attacks(a_.get_unit().attacks_left()-1);
        EoHS.set_unit_attribute_immediate(a.unit, "moves", 0) --a_.get_unit().set_movement(-1);
      end
      return --return;
    end --}

    EoHS.assert(a.f.attack, "EoHS.game_action_simulations.attack_unit An invalid attacker weapon got selected.")
    if not (extras and (extras.spend_moves_and_attacks == false)) then
      EoHS.set_unit_attribute_immediate(a.unit, "attacks_left", a.unit.attacks_left - 1) --a_.get_unit().set_attacks(a_.get_unit().attacks_left()-1);
      --VALIDATE(a_.weapon_ < static_cast<int>(a_.get_unit().attacks().size()),
      --        _("An invalid attacker weapon got selected."));
      --a_.get_unit().set_movement(a_.get_unit().movement_left() -
      --        a_.get_unit().attacks()[a_.weapon_].movement_used());
      EoHS.set_unit_attribute_immediate(a.unit, "moves", a.unit.moves - (a.f.attack.movement_used or 100000)) -- accurate to hard-coded value in unit_types.hpp:62 (1.10.7)
      --a_.get_unit().set_state(unit::STATE_NOT_MOVED,false);
    end
    EoHS.set_unit_attribute_immediate(a.unit, "resting", false) --a_.get_unit().set_resting(false);
    EoHS.set_unit_attribute_immediate(d.unit, "resting", false) --d_.get_unit().set_resting(false);

    --// If the attacker was invisible, she isn't anymore!
    EoHS.set_unit_status_immediate(a.unit, "uncovered", true) --a_.get_unit().set_state(unit::STATE_UNCOVERED, true);

    fire_event("attack")
    if not valid then fire_event("attack_end"); return end
      
    local defender_strikes_first = d.f.firststrike and not a.f.firststrike
    local extra_rounds = math.max(a.f.rounds, d.f.rounds or 1) - 1;
    do_animation({{
      flag = "draw_weapon",
      { "filter", { x=a.unit.x, y=a.unit.y, }},
      { "primary_attack", { name = a.f.attack.name }},
      with_bars = true,
    }})

    --bc_ = new battle_context(units_, a_.loc_, d_.loc_, a_.weapon_, d_.weapon_);
    --a_stats_ = &bc_->get_attacker_stats();
    --d_stats_ = &bc_->get_defender_stats();
    --if(a_stats_->weapon) {
    --        a_.weap_id_ = a_stats_->weapon->id();
    --}
    --if(d_stats_->weapon) {
    --        d_.weap_id_ = d_stats_->weapon->id();
    --}

    --try {
    --        fire_event("attack");
    --} catch (attack_end_exception) {
    --        return;
    --}
    --refresh_bc();

    --DBG_NG << "getting attack statistics\n";
    --statistics::attack_context attack_stats(a_.get_unit(), d_.get_unit(), a_stats_->chance_to_hit, d_stats_->chance_to_hit);

    --[[{
            // Calculate stats for battle
            combatant attacker(bc_->get_attacker_stats());
            combatant defender(bc_->get_defender_stats());
            attacker.fight(defender,false);
            const double attacker_inflict = static_cast<double>(d_.get_unit().hitpoints()) - defender.average_hp();
            const double defender_inflict = static_cast<double>(a_.get_unit().hitpoints()) - attacker.average_hp();

            attack_stats.attack_expected_damage(attacker_inflict,defender_inflict);
    }

    a_.orig_attacks_ = a_stats_->num_blows;
    d_.orig_attacks_ = d_stats_->num_blows;
    a_.n_attacks_ = a_.orig_attacks_;
    d_.n_attacks_ = d_.orig_attacks_;
    a_.xp_ = d_.get_unit().level();
    d_.xp_ = a_.get_unit().level();

    bool defender_strikes_first = (d_stats_->firststrike && !a_stats_->firststrike);
    unsigned int rounds = std::max<unsigned int>(a_stats_->rounds, d_stats_->rounds) - 1;
    const int attacker_side = a_.get_unit().side();
    const int defender_side = d_.get_unit().side();

    static const std::string poison_string("poison");

    LOG_NG << "Fight: (" << a_.loc_ << ") vs (" << d_.loc_ << ") ATT: " << a_stats_->weapon->name() << " " << a_stats_->damage << "-" << a_stats_->num_blows << "(" << a_stats_->chance_to_hit << "%) vs DEF: " << (d_stats_->weapon ? d_stats_->weapon->name() : "none") << " " << d_stats_->damage << "-" << d_stats_->num_blows << "(" << d_stats_->chance_to_hit << "%)" << (defender_strikes_first ? " defender first-strike" : "") << "\n";

    // Play the pre-fight animation
    unit_display::unit_draw_weapon(a_.loc_,a_.get_unit(),a_stats_->weapon,d_stats_->weapon,d_.loc_,&d_.get_unit());]]
    
    local perform_hit = function(h, v)
      local hits = EoHS.random("0..99") < h.f.chance_to_hit
      -- EoHS specific rule: Some units are immune to spell damage.
      local immune = extras and extras.is_spell and EoHS.unit_is_immune_to_direct_spell_damage(v.unit)
      if hits then
        wesnoth.set_variable("damage_inflicted", h.f.damage)
      end
      
      -- TODO proper textdomain
      if hits and h.f.poisons and not EoHS.get_subtag_attribute(v.unit, "status.poisoned") then
        float_label(v.unit.x, v.unit.y, '<span color="#ff0000">'..(v.unit.gender=="female" and _"female^poisoned" or _"poisoned")..'</span>')
      end
      if hits and h.f.slows   and not EoHS.get_subtag_attribute(v.unit, "status.slowed"  ) then
        float_label(v.unit.x, v.unit.y, '<span color="#ff0000">'..(v.unit.gender=="female" and _"female^slowed"   or _"slowed"  )..'</span>')
      end
      if hits and h.f.petrifies then
        float_label(v.unit.x, v.unit.y, '<span color="#ff0000">'..(v.unit.gender=="female" and _"female^petrified" or _"petrified")..'</span>')
      end
      
      local anim_hits = hits and ((h.f.damage >= v.unit.hitpoints) and "kill" or "hit") or "miss"
      EoHS.face_towards(h.unit, v.unit.x, v.unit.y, true)
      EoHS.face_towards(v.unit, h.unit.x, h.unit.y, true)
      EoHS.set_unit_attribute_immediate(h.unit, "facing", h.unit.facing)
      EoHS.set_unit_attribute_immediate(v.unit, "facing", v.unit.facing)
      -- TODO: Can we fake HP bar sliding? (And remember to do it for parallel attacks)
      do_animation({
        {
          flag="attack",
          {"filter",{x=h.unit.x,y=h.unit.y}},
          {"primary_attack",{name=h.f.attack.name}}, -- TODO proper handling for attacks the unit doesn't have - which won't match the filter
          {"secondary_attack",{name=v.f.attack and v.f.attack.name}},
          hits = anim_hits,
          text = (hits and not immune) and h.f.drains and h.f.next_drains_damage or nil,
          red=0,green=255,blue=0,
          with_bars = true,
        },
        (not immune) and { -- Two reasons not to play defense animations when immune:
                           -- One, you don't have to defend (arguably). Two, so that wizards who attack themselves don't
                           --   have the attack anim overridden by the defense one.
          flag="defend",
          {"filter",{x=v.unit.x,y=v.unit.y}},
          {"primary_attack",{name=h.f.attack.name}},
          {"secondary_attack",{name=v.f.attack and v.f.attack.name}},
          hits = anim_hits,
          text = immune and _"immune" or (hits and h.f.damage or nil),
          red=immune and 128 or 255,green=immune and 128 or 0,blue=immune and 255 or 0,
          with_bars = true,
        } or nil
      })
      

      -- I have NO idea why this is computed before events and applied after events,
      -- but it's not difficult for me to be faithful to that behavior, so I guess I will.
      local drains_damage = 0
      if h.f.drains then
              -- // don't drain so much that the attacker gets more than his maximum hitpoints
              -- drains_damage = std::min<int>(damage / 2, attacker.get_unit().max_hitpoints() - attacker.get_unit().hitpoints());
              -- // don't drain more than the defenders remaining hitpoints
              -- drains_damage = std::min<int>(drains_damage, defender.get_unit().hitpoints() / 2);
        drains_damage = math.min(math.floor(h.f.damage / 2), h.unit.max_hitpoints - h.unit.hitpoints, math.floor(v.unit.hitpoints / 2))
      end

      if hits and not immune then EoHS.set_unit_attribute_immediate(v.unit, "hitpoints", v.unit.hitpoints - h.f.damage) end
      local dies = v.unit.hitpoints <= 0

      fire_event(h.f.role..(hits and "_hits" or "_misses"))
      if not valid then fire_event("attack_end"); return end

      -- I wasn't going to make spell immunity affect anything but damage, but if someone managed
      -- to get a drain spell for some reason, it wouldn't do to give HP when none was taken...
      if hits and (drains_damage > 0) and not immune then
        EoHS.set_unit_attribute_immediate(h.unit, "hitpoints", h.unit.hitpoints + drains_damage)
      end
      
      if dies then
        h.xp_gained = EoHS.kill_experience(v.unit.level)
        v.xp_gained = 0
        local undead_variation = v.unit.undead_variation
        fire_event("attack_end")
        load_ac()
        if not valid then return end
        fire_event("last_breath", v==d)
        load_ac()
        if not valid then return end
        if v.unit.hitpoints > 0 then return end
        do_animation({{
          flag="death",
          {"filter",{x=v.unit.x,y=v.unit.y}},
          {"primary_attack",{name=h.f.attack.name}},
          {"secondary_attack",{name=v.f.attack and v.f.attack.name}},
          with_bars = false,
        }})
        fire_event("die", v==d)
        load_ac()
        if not valid then return end
        if v.unit.hitpoints > 0 then return end
        if v.f.on_map then
          EoHS.remove_unit(v.unit.x,v.unit.y)
          if h.unit and h.f.plagues then
            wesnoth.put_unit({
              x = v.unit.x,
              y = v.unit.y,
              side = h.unit.side,
              type = h.f.plague_type,
              variation = v.unit.undead_variation,
              attacks_left = 0,
              moves = 0,
              -- EoHS-specific feature: (TODO should we propagate summon status?)
              {"variables",{EoHS_is_swarm=EoHS.get_unit_variable(h.unit, "is_swarm")}},
            })
          end
          v.unit = nil
          record_units()
        end
        return
      end

      if hits then
        if h.f.poisons then EoHS.set_unit_status_immediate(v.unit, "poisoned", true) end
        if h.f.slows   then EoHS.set_unit_status_immediate(v.unit, "slowed"  , true) end
        if h.f.petrifies then
          EoHS.set_unit_status_immediate(v, "petrified", true)
          fire_event("petrified", v==d)
          return false
        end
      end
      
      return true
    end
    
    local a_orig_attacks = a.f.attacks
    local d_orig_attacks = d.f.attacks or 0
    local a_n_attacks = a_orig_attacks
    local d_n_attacks = d_orig_attacks
    a.xp_gained = d.unit.level
    d.xp_gained = a.unit.level
    -- TODO: handle parallel animations nicely WRT berserk and one unit attacking many
    while true do -- for (;;) {
            -- DBG_NG << "start of attack loop...\n";
           -- ++abs_n_attack_;

      if (a_n_attacks > 0) and not defender_strikes_first then      -- if (a_.n_attacks_ > 0 && !defender_strikes_first) {
        if not perform_hit(a,d) then break end    --         if (!perform_hit(true, attack_stats)) break;
        a_n_attacks = a_n_attacks - 1
      else
        do_animation({}) -- make the rounds line up in parallel attacks
      end      -- }
      if not valid then break end

            -- // If the defender got to strike first, they use it up here.
      defender_strikes_first = false      -- defender_strikes_first = false;
            -- ++abs_n_defend_;
      if d_n_attacks > 0 then      -- if (d_.n_attacks_ > 0) {
        if not perform_hit(d,a) then break end    --         if (!perform_hit(false, attack_stats)) break;
        d_n_attacks = d_n_attacks - 1
      else
        do_animation({}) -- make the rounds line up in parallel attacks
      end      -- }
      if not valid then break end

            -- // Continue the fight to death; if one of the units got petrified,
            -- // either n_attacks or n_defends is -1
      if (extra_rounds > 0) then     -- if(rounds > 0 && d_.n_attacks_ == 0 && a_.n_attacks_ == 0) {
        a_n_attacks = a_orig_attacks    --         a_.n_attacks_ = a_.orig_attacks_;
        d_n_attacks = d_orig_attacks    --         d_.n_attacks_ = d_.orig_attacks_;
        extra_rounds = extra_rounds - 1    --         --rounds;
        defender_strikes_first = d.f.firststrike and not a.f.firststrike    --         defender_strikes_first = (d_stats_->firststrike && ! a_stats_->firststrike);
      end      -- }

      if (a_n_attacks <= 0) and (d_n_attacks <= 0) then    -- if (a_.n_attacks_ <= 0 && d_.n_attacks_ <= 0) {
        fire_event("attack_end")
        break    --         fire_event("attack_end");
      end      --         refresh_bc();
            --         break;
            -- }
    end -- }

    if a.unit then
      EoHS.set_unit_attribute_immediate(a.unit, "experience", a.unit.experience + a.xp_gained)
    end
    if d.unit then
      EoHS.set_unit_attribute_immediate(d.unit, "experience", d.unit.experience + d.xp_gained)
    end
    if a.unit then do_animation({{
      flag = "sheath_weapon",
      { "filter", { x=a.unit.x, y=a.unit.y, }},
      { "primary_attack", { name = a.f.attack.name }},
      with_bars = true,
    }}) end
    
    EoHS.game_action_simulations.current_attack_context = nil
    
    --[[// Eli notes: split this wesnoth "TO DO" with a space so it doesn't show up in my grep for EoHS ones: TO DO: if we knew the viewing team, we could skip some of these display update
    if (update_att_fog_ && (*resources::teams)[attacker_side - 1].uses_fog())
    {
            recalculate_fog(attacker_side);
            if (update_display_) {
                    resources::screen->invalidate_all();
                    resources::screen->recalculate_minimap();
            }
    }
    if (update_def_fog_ && (*resources::teams)[defender_side - 1].uses_fog())
    {
            recalculate_fog(defender_side);
            if (update_display_) {
                    resources::screen->invalidate_all();
                    resources::screen->recalculate_minimap();
            }
    }

    if (update_minimap_ && update_display_) {
            resources::screen->recalculate_minimap();
    }

    if (a_.valid()) {
            unit &u = a_.get_unit();
            u.set_standing();
            u.set_experience(u.experience() + a_.xp_);
    }

    if (d_.valid()) {
            unit &u = d_.get_unit();
            u.set_standing();
            u.set_experience(u.experience() + d_.xp_);
    }

    unit_display::unit_sheath_weapon(a_.loc_,a_.valid()?&a_.get_unit():NULL,a_stats_->weapon,
                    d_stats_->weapon,d_.loc_,d_.valid()?&d_.get_unit():NULL);

    if (update_display_){
            resources::screen->invalidate_unit();
            resources::screen->invalidate(a_.loc_);
            resources::screen->invalidate(d_.loc_);
            resources::screen->draw(true, true);
    }

    if(OOS_error_) {
            replay::process_error(errbuf_.str());
    }
}
]]
  --}
  end,
}

-->>)}
