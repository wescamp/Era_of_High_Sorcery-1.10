this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- unit_types.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")

EoHS.do_special_advancement_next = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard") or ((unit.advances_to == unit.type) and EoHS.get_unit_variable(unit, "is_summon"))
end

local wizard_max_experience_table = {
  wesnoth.unit_types[     "Mage"].max_experience,
  wesnoth.unit_types[ "Red Mage"].max_experience,
  wesnoth.unit_types["Arch Mage"].max_experience,
}
EoHS.wizard_max_experience = function(level)
  if level < 1 then return math.ceil(wizard_max_experience_table[1] / (2-level)) end
  if level > 3 then return wizard_max_experience_table[3] + (120*(level - 3)) end
  return wizard_max_experience_table[level]
end
local wizard_max_hitpoints_table = {
  wesnoth.unit_types[      "Mage"].max_hitpoints,
  wesnoth.unit_types[  "Red Mage"].max_hitpoints,
  wesnoth.unit_types[ "Arch Mage"].max_hitpoints,
  wesnoth.unit_types["Great Mage"].max_hitpoints,
}
EoHS.wizard_max_hitpoints = function(level)
  local val
      if level < 1 then val = math.ceil(wizard_max_hitpoints_table[1] / (2-level))
  elseif level > 4 then val = wizard_max_hitpoints_table[4] + (11*(level - 4))
  else val = wizard_max_hitpoints_table[level] end
  return val + 10
end
EoHS.appropriate_wizard_unit_type = function(reference_type, level)
  local human_line = {["Mage"]=true,["Red Mage"]=true,["Arch Mage"]=true,["Great Mage"]=true}
  local dwarf_line = {["Dwarvish Runesmith"]=true,["Dwarvish Runemaster"]=true,["Dwarvish Arcanister"]=true}
  local maleelf_line = {["Elvish Lord"]=true,["Elvish High Lord"]=true}
  if human_line[reference_type] then
        if level <= 1 then return       "Mage"
    elseif level == 2 then return   "Red Mage"
    elseif level == 3 then return  "Arch Mage"
    else                   return "Great Mage" end
  end
  if dwarf_line[reference_type] then
        if level  < 3 then return "Dwarvish Runesmith"
    elseif level  < 4 then return "Dwarvish Runemaster"
    else                   return "Dwarvish Arcanister" end
  end
  if maleelf_line[reference_type] then
        if level  < 3 then return "Elvish Lord"
    else                   return "Elvish High Lord" end
  end
  
  return reference_type
end

-- TODO: Rename this function to be in line with the other functions' style?
-- (e.g. the "all" is unnecessary and we could use something like "attributes" rather than "adjustments",
--   since this mostly is intended to overwrite things rather than tweaking them)
EoHS.update_all_type_adjustments = function(unit, only_a_prototype)
  local variables = EoHS.force_unit_variables(unit)
  if not variables.original_type then variables.original_type = unit.type end
  local original_type = variables.original_type
  local reference_type = original_type
  if variables.is_wizard and (reference_type == "Elvish Lady") then reference_type = EoHS.appropriate_wizard_unit_type("Elvish Lord", variables.wizard_level) end
  local type_cfg = EoHS.get_unit_type(reference_type)
  unit.level = type_cfg.level
  local observed_type = unit.type
  unit.type = original_type
  unit.advances_to = type_cfg.advances_to
  unit.alignment = type_cfg.alignment
  unit.cost = type_cfg.cost
  unit.race = type_cfg.race
  variables.despair_ability = nil
  local type_in = function(list) for t in EoHS.comma_separated_values(list) do if original_type == t then return true end end; return false end
  
  local hitpoints = type_cfg.hitpoints
  local experience = type_cfg.experience
  local extra_effects_before_extra_attacks = {}
  local extra_attacks = {}
  local extra_effects = {}
  local make_effect = function(apply_to, contents, before_extra_attacks)
    contents.apply_to = apply_to
    table.insert(before_extra_attacks and extra_effects_before_extra_attacks or extra_effects, { "effect", contents })
  end
  -- We'd remove AMLA for units with special advancements, but we can't; fortunately it's overridden by the valid advances_to
  local first_attack = helper.get_child(type_cfg, "attack")
  local default_melee_names = {first_attack and first_attack.name}
  local default_melee_effects = {}
  
  if variables.is_crypt then
    variables.type_name_override = _"Crypt"
    variables.type_description_override = _"The crypt of a Lich. As long as this crypt exists, the lich cannot truly die."
    unit.profile = "unit_image"
    make_effect("remove_attacks", {}, true)
    make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_SUBMERGE } }) -- would be too cruel if it was effective at all, otherwise pointless/annoying
    make_effect("movement", { set=0 })
    
    make_effect("defense", { replace = true, { "defense", { 
      flat=80, fungus=80, hills  =80, mountains =80,
      sand=80, forest=80, village=80,
      cave=80, frozen=80, castle =80, unwalkable=80, }}})
    make_effect("resistance", { replace = true, { "resistance", { blade = 40, pierce = 40, impact = 50, fire = 50, arcane = 60, cold = 40 }}, })
    make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_REGENERATES } })
  end
  
  if EoHS.get_unit_variable(unit, "is_summon") then
    if (original_type == "Chocobone") then
      unit.cost = 26
      unit.advances_to = "Death Knight"
      experience = 90
    elseif (original_type == "Death Knight") then
      unit.cost = 48
      make_effect("movement", { set = 9 })
      make_effect("attack", { name = "battle axe", increase_damage = -2 })
      table.insert(extra_attacks, {
        name = "spear",
        description = _"spear",
        type = "pierce",
        range = "melee",
        damage = 14,
        number = 2,
        { "specials", EoHS.macros.WEAPON_SPECIAL_CHARGE },
      })
    end
    
    if (original_type ==       "Wolf") then experience = 30; unit.advances_to = "Great Wolf"; unit.cost = 15 end
    if (original_type == "Great Wolf") then experience = 65; unit.advances_to =   "Direwolf"; make_effect("attack", { increase_damage = 2 }) end
    if (original_type ==   "Direwolf") then                                                   make_effect("attack", { increase_damage = 2 }) end
    
    if (original_type == "Fire Guardian") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 12
        unit.advances_to = original_type
        experience = 42
      else
        variables.type_name_override = _"Fire Aggressor"
        unit.level = 2
        unit.cost = 26
        experience = 100
        hitpoints = hitpoints + 17
        make_effect("attack", { name = "fire claws", increase_damage = 2, increase_attacks = 1 })
        make_effect("attack", { name = "fire breath", increase_damage = 2, increase_attacks = 1 })
        make_effect("image_mod", { add = "~CS(50,-60,-90)", })
      end
    end
    
    if (original_type == "Giant Scorpion") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 19
        unit.advances_to = original_type
        experience = 34
      else
        variables.type_name_override = _"Plated Scorpion"
        unit.level = 2
        unit.cost = 29
        experience = 100
        hitpoints = hitpoints + 10
        make_effect("resistance", { replace = true, { "resistance", { blade = 70, pierce = 70, fire = 120, arcane = 110, cold = 100 }}, })
        make_effect("attack", { name = "pincers", increase_damage = 2 })
        make_effect("attack", { name = "sting", increase_attacks = 1 })
        make_effect("image_mod", {
          { "color_palette", {
            EoHS_giant_scorpion_palette = "394960,8796b3,435778,56657c,8c9bb2,6b7b94,6b7c98,7686a0,00274f,313f5a,273649,131a24,1a2835,39455f,2f3241,31415b,92acc7,7994af,8199bd,576276,596d88,717b9e,2e3b5b,5f6d88,b5b0ce,9b98b7,5f607f,b1add0,8384a3,8180a2,414c5e,737492,384c71,1d2c49",
          }},
          { "color_range", {
            id = "EoHS_bigger_scorpion_range",
            rgb = "921e00,ffe267,000000",
          }},
          add = "~SCALE(84,84)~RC(EoHS_giant_scorpion_palette>EoHS_bigger_scorpion_range)",
        })
      end
    end
    
    if (original_type == "Gryphon") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 28
        unit.advances_to = original_type
        experience = 74
      else
        variables.type_name_override = _"Dire Gryphon"
        unit.level = 3
        unit.cost = 48
        experience = 150
        hitpoints = hitpoints + 18
        make_effect("attack", { name = "claws", increase_damage = 4 })
        make_effect("movement", { increase = 1 })
        make_effect("image_mod", { add = "~CS(0,-20,-60)" })
      end
    end
    
    if (original_type == "Water Serpent") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 24
        unit.advances_to = original_type
        experience = 68
      else
        variables.type_name_override = _"Slipstream Serpent"
        unit.level = 3
        unit.cost = 42
        experience = 150
        hitpoints = hitpoints + 12
        make_effect("attack", { name = "fangs", increase_attacks = 1, increase_damage = 1 })
        make_effect("movement", { increase = 1 })
        make_effect("image_mod", { add = "~CS(-60,-60,0)" })
      end
    end
    
    if (original_type == "Sea Serpent") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 38
        unit.level = 2
        hitpoints = hitpoints - 9
        unit.advances_to = original_type
        experience = 88
      else
        variables.type_name_override = _"Sea Behemoth"
        unit.cost = 58
        hitpoints = hitpoints + 9
        make_effect("attack", { name = "fangs", increase_damage = 7 })
        make_effect("movement", { increase = 2 })
        make_effect("image_mod", { add = w111 and "~CS(-30,-70,-90)" or "~CS(-60,-60,0)" })
        local name = _"open water only"
        local description = _"This attack can be used in deep water, shallow water, and coastal reefs, but not in river ford, swamp, or land terrains."
        table.insert(extra_attacks, {
          name = "gigantic splash",
          description = _"gigantic splash",
          icon = "attacks/waterspray.png",
          type = "impact",
          range = "ranged",
          damage = 8,
          number = 3,
          {"specials",{
            EoHS.attack_disabling_special({
              name = name,
              description = description,
              name_inactive = name,
              description_inactive = description,
              {"filter_self",{
                {"not",{
                  {"filter_location",{
                    terrain="Ww*,Wo*",
                    {"not",{ terrain="Wwf" }}
                  }}
                }}
              }}
            })
          }}
        })
      end
    end
    
    if type_in("Ghost,Shadow,Nightgaunt,Wraith,Spectre") then
      unit.cost = type_cfg.cost - 4
    end
    if type_in("Wose,Elder Wose,Ancient Wose") then
      unit.cost = type_cfg.cost - 2
    end
    if type_in("Drake Fighter,Drake Warrior,Drake Blademaster") then
      unit.cost = type_cfg.cost + 3
      if original_type == "Drake Fighter" then
        variables.type_name_override = _"Arctic Drake"
      elseif original_type == "Drake Warrior" then
        variables.type_name_override = _"Arctic Warrior"
      elseif original_type == "Drake Blademaster" then
        variables.type_name_override = _"Arctic Blademaster"
      end
      make_effect("image_mod", {
        { "color_palette", {
          EoHS_drake_fighter_palette = "86ac53,fde9f1,fde6ef,fadb85,f7df8e,f6db84,dfc799,c7d95e,c3d355,c1d553,c19057,a2c157,9dba50,99b94e,7ca448,679345,5e8d44,57624d,573d2d,53844a,4c5742,4a5640,487a3f,3c513e,324634,2d4331,242e12,1c250d,151f06,100506",
        }},
        { "color_range", {
          id = "EoHS_blue_drake_range",
          rgb = "8888ff,ffffff,000000",
        }},
        add = "~RC(EoHS_drake_fighter_palette>EoHS_blue_drake_range)",
      })
      make_effect("resistance", { replace = true, { "resistance", { cold = 80, arcane = 80, }}, })
      -- I didn't originally intend to change its snow movement/defense, but the "arctic" theme requires me to (and I have nothing against it)
      make_effect("movement_costs", { replace = true, { "movement_costs", { frozen = 1, }}, })
      make_effect("defense",        { replace = true, { "defense",        { frozen = 60, }}, })
    end
    
    if original_type == "Skeletal Dragon" then
      unit.level = -4
      make_effect("new_ability", { { "abilities", {{ "dummy", {name=_"negation",description=_"This unit has negative upkeep and gives negative experience to any unit that fights it."} }} } })
    end
    
    if original_type == "Fire Dragon" then
      variables.type_name_override = _"Dragon"
      make_effect("remove_attacks", { range="ranged" }, true)
      make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1 } })
      make_effect("attack", {
        name = "bite",
        { "set_specials", {
          mode = "append",
          { "dummy", {
            id = "EoHS_devour",
            name = _"devour",
            description = _"Whenever this unit kills another unit with this attack, this unit is healed by the killed unit's max hitpoints."
          }},
        }},
      })
      
      local dragon = EoHS.get_fake_subtag(variables, "dragon")
      hitpoints = dragon.hitpoints or 1 -- to satisfy the prototype
      unit.alignment = dragon.alignment
      make_effect("movement", { set = dragon.moves })
      
      local resistances = function(r)
        make_effect("resistance", { replace = true, { "resistance", r }, })
      end
      local defenses = function(r)
        make_effect("defense", { replace = true, { "defense", r }, })
      end
      local movement_costs = function(r)
        make_effect("movement_costs", { replace = true, { "movement_costs", r }, })
      end
      
      local most_terrains = {
        deep_water=1,
        shallow_water=1,
        reef=1,
        swamp_water=1,
        flat=1,
        sand=1,
        forest=1,
        hills=1,
        mountains=1,
        village=1,
        castle=1,
        frozen=1,
        unwalkable=1,
      }
      local d,m = {},{}
      if dragon.movetype == "fly" then
        for k in pairs(most_terrains) do d[k] = 50; m[k]=1 end
      elseif dragon.movetype == "walk" then
        -- drakefoot
        d = {
          unwalkable=100,
          deep_water=100,
          shallow_water=80,
          reef=70,
          swamp_water=80,
          flat=70,
          sand=60,
          forest=60,
          hills=60,
          mountains=60,
          village=60,
          castle=60,
          cave=70,
          frozen=80,
          fungus=60,
        }
        m = {
          unwalkable=99,
          deep_water=99,
          shallow_water=3,
          reef=2,
          swamp_water=3,
          flat=1,
          sand=1,
          forest=2,
          hills=1,
          mountains=1,
          village=1,
          castle=1,
          cave=2,
          frozen=3,
          fungus=2,
        }
      end
      
      dragon.breath_names = nil
      local make_breath = function(name, description, dam_type, specials)
        dragon.breath_names = (dragon.breath_names and dragon.breath_names.."," or "")..name
        if dragon.breath_cth == "marksman" then table.insert(specials, 1, EoHS.macros.WEAPON_SPECIAL_MARKSMAN[1]) end
        if dragon.breath_cth == "magical" then table.insert(specials, 1, EoHS.macros.WEAPON_SPECIAL_MAGICAL[1]) end
        table.insert(specials, { "dummy", {
          id = "EoHS_dragon_breath_info",
          name = _"area option",
          description = EoHS.substitute(_"The dragon may use this attack, at half damage, to strike every unit in a cone $1| hexes long and $2| degrees wide. This action costs $3| mana.", {dragon.breath_length, dragon.breath_spread*2, dragon.breath_mana})
        }})
        table.insert(extra_attacks, {
          name = name,
          description = description,
          icon = "attacks/fire-breath-drake.png",
          type = dam_type,
          range = "ranged",
          damage = dragon.breath_damage,
          number = dragon.breath_swings,
          {"specials",specials}
        })
      end
      local original_palette = "fff9d5,987b8c,aecacc,ffe39f,3d5a4b,ab718d,ff8b19,d26a2c,f6e795,ffc946,ffa32c,d9524f,b41056,b83d00,872819,c64e32,c06d01,640f46,631205,724149,430027"
      local palette_id = ""
      local rgb_funcs = {}
      local rgbonus = function(c,bonus)
        if (c==0) or (c==255) or (bonus==0) or (bonus==nil) then return c end
        return math.floor(0.5+((math.atan(math.tan(((c/255)-0.5)*math.pi)+(bonus*math.pi/255))/math.pi)+0.5)*255)
      end
      local rgb_map = function(rgb,func)
        rgb.r = func(rgb.r)
        rgb.g = func(rgb.g)
        rgb.b = func(rgb.b)
      end
      local rgbonize = function(rgb,r,g,b)
        rgb.r = rgbonus(rgb.r,r)
        rgb.g = rgbonus(rgb.g,g)
        rgb.b = rgbonus(rgb.b,b)
        EoHS.assert(rgb.r>=0)
        EoHS.assert(rgb.r<=255)
        EoHS.assert(rgb.g>=0)
        EoHS.assert(rgb.g<=255)
        EoHS.assert(rgb.b>=0)
        EoHS.assert(rgb.b<=255)
      end
      local make_mod = function(id, rgb_func)
        table.insert(rgb_funcs, rgb_func)
        palette_id = palette_id..id
      end
      if dragon.type == "fire" then
        make_breath("fire breath", _"fire breath", "fire", {})
      elseif dragon.type == "acid" then
        make_mod("acid", function(c) c.r,c.g,c.b=c.g,c.r,c.b end)
        make_breath("acid breath", _"acid breath", "fire", {EoHS.macros.WEAPON_SPECIAL_POISON[1]})
        resistances({ fire = 50, cold = 100, arcane = 130 })
      elseif dragon.type == "lightning" then
        make_mod("lightning", function(c) c.r,c.g,c.b=(3*c.r+c.g)/4,(2*c.r+2*c.g)/4,c.b/2 end)
        make_breath("lightning breath", _"lightning breath", "lightning", {EoHS.macros.WEAPON_SPECIAL_SLOW[1]})
        resistances({ fire = 50, cold = 100, arcane = 130, lightning = 0 })
      elseif dragon.type == "ice" then
        make_mod("ice", function(c)
          c.r,c.g,c.b=c.b,c.g,c.r
          rgbonize(c,100,100,100)
        end)
        make_breath("cold breath", _"cold breath", "cold", {})
        make_breath("ice breath", _"ice breath", "blade", {})
        resistances({ blade = 90, pierce = 80, impact = 110, fire = 150, cold = 0, arcane = 130 })
        m.frozen = 1
        d.frozen = math.min(60, d.frozen or 100)
      elseif dragon.type == "water" then
        make_mod("water", function(c)
          c.r,c.g,c.b=c.b,c.g,c.r
          rgbonize(c,-50,0,0)
        end)
        make_breath("water breath", _"water breath", "impact", {})
        resistances({ blade = 110, pierce = 110, impact = 60, fire = 100, cold = 50, arcane = 130 })
        m.shallow_water = 1
        m.swamp_water   = math.min( 2, m.swamp_water   or  99)
        m.deep_water    = 1
        m.reef          = 1
        d.shallow_water = math.min(70, d.shallow_water or 100)
        d.swamp_water   = math.min(70, d.swamp_water   or 100)
        d.deep_water    = math.min(70, d.deep_water    or 100)
        d.reef          = math.min(60, d.reef          or 100)
      elseif dragon.type == "spirit" then
        make_mod("spirit", function(c)
          local avg = (c.g+c.b+c.r)/3
          local fix=function(q) return (q>avg) and math.max(avg,q-30) or math.min(avg,q+30) end
          c.r,c.g,c.b=fix(c.g),fix(c.b),fix(c.r)
          rgbonize(c,avg-100,avg-100,avg-100)
        end)
        make_breath("spirit breath", _"spirit breath", "arcane", {EoHS.macros.WEAPON_SPECIAL_PLAGUE[1]})
        resistances({ blade = 110, pierce = 110, impact = 110, fire = 50, cold = 50, arcane = 0 })
      end
      defenses(d); movement_costs(m)
      
      -- make breath_cs before abilities (abilities don't affect breath type)
      local cs_rgb = {r=210,g=106,b=44}
      for i,f in ipairs(rgb_funcs) do f(cs_rgb) end
      dragon.breath_cs = "~CS("..(cs_rgb.r-128)..","..(cs_rgb.g-128)..","..(cs_rgb.b-128)..")"
      
      if dragon.ability == "leadership" then
        make_effect("new_ability", { { "abilities", EoHS.abilities.leadership(unit.level) }})
      elseif dragon.ability == "despair" then
        make_mod("despair", function(c) rgbonize(c,-50,-100,-50) end)
        make_effect("new_ability", { { "abilities", EoHS.abilities.despair } })
        variables.despair_ability = true
      elseif dragon.ability == "protection" then
        make_mod("protection", function(c)
          local avg = (c.g+c.b+c.r)/3
          if avg < 100 then
            if (dragon.type == "fire") or (dragon.type == "acid") then c.r,c.g,c.b=c.b,c.r,c.g else c.r,c.g,c.b=c.g,c.b,c.r end
          end
          --local w = 100-math.min(100,avg)
          --rgbonize(c,-w,w,0)
        end)
        make_effect("new_ability", { { "abilities", EoHS.abilities.protection } })
      elseif dragon.ability == "time_of_day" then
        if dragon.alignment == "lawful" then
          make_mod("illuminates", function(c)
            rgb_map(c, function(q) return 255-math.floor((255-q)*0.9) end)
            rgbonize(c,100,80,60)
          end)
          make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_ILLUMINATES } })
        elseif dragon.alignment == "chaotic" then
          make_mod("deluminates", function(c)
            rgb_map(c, function(q) return math.floor(q*0.9) end)
            rgbonize(c,-100,-80,-60)
          end)
          make_effect("new_ability", { { "abilities", EoHS.abilities.deluminates } })
        else
          make_mod("twilight", function(c)
            rgb_map(c, function(q) return math.floor(13.25+q*0.9) end)
            rgbonize(c,100-c.r,100-c.g,100-c.b)
          end)
          make_effect("new_ability", { { "abilities", EoHS.abilities.twilight } })
        end
      end
      
      palette_id = "EoHS_dragon_"..palette_id.."_palette"
      make_effect("image_mod", {
        { "color_palette", {
          EoHS_dragon_palette = original_palette,
          [palette_id] = string.gsub(original_palette, "(..)(..)(..)(,?)", function(rs,gs,bs,comma)
            local rgb={}
            rgb.r,rgb.g,rgb.b = tonumber(rs,16),tonumber(gs,16),tonumber(bs,16)
            for i,f in ipairs(rgb_funcs) do f(rgb) end
            return string.format("%.2x%.2x%.2x",rgb.r,rgb.g,rgb.b)..comma
          end)
        }},
        add = "~PAL(EoHS_dragon_palette>"..palette_id..")",
      })
    end
  end
  
  if EoHS.get_unit_variable(unit, "is_wizard") then
    local skills = EoHS.get_unit_skillset(unit)
    
    unit.level = EoHS.get_unit_variable(unit, "wizard_level") or unit.level
    unit.advances_to = EoHS.appropriate_wizard_unit_type(original_type, unit.level + 1)
    experience = EoHS.wizard_max_experience(unit.level)
    hitpoints = EoHS.wizard_max_hitpoints(unit.level)
    unit.cost = 15 + unit.level*unit.level*8
    unit.description = EoHS.rules
    
    --[[if (original_type == "Mage") then
      make_effect("remove_attacks", { name="missile" })
    end
    if type_in("Red Mage,Arch Mage,Great Mage") then
      make_effect("remove_attacks", { name="fireball" })
    end
    if (original_type == "Lich") then
      make_effect("remove_attacks", { name="chill tempest" })
      make_effect("remove_attacks", { name="shadow wave" })
    end]]
    if not EoHS.get_unit_variable(unit, "spiritform") then make_effect("remove_attacks", { range="ranged" }, true) end
    if original_type == "Elvish Lady" then
      for attack in helper.child_range(type_cfg, "attack") do
        if attack.range == "melee" then
          table.insert(extra_attacks, attack)
        end
      end
    end
    
    local make_attack = function(skill_name, upgrade_array, bonus, attack)
      local skill = EoHS.skillset_realm_rank(skills, skill_name)
      if skill > 0 then
        local upgrade_total = math.max(0, math.min(skill, unit.level)) + 1
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        attack.range = "ranged"
        attack.damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus)
        attack.number = upgrade_array[upgrade_array_index][2]
        table.insert(attack, { "specials", EoHS.macros.WEAPON_SPECIAL_MAGICAL })
        table.insert(extra_attacks, attack)
      end
    end
    make_attack("evocation",
      {{ 6,2},{ 7,3},{ 8,4}}, 4,
      {
        name = "EoHS_evocation_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("fireball"),
        icon = "attacks/fireball.png",
        type = "fire",
      }
    )
    make_attack("nature_magic",
      {{ 4,3},{ 5,4},{ 7,4},{8,5},{10,5}}, 2,
      {
        name = "EoHS_nature_magic_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("faerie fire"),
        icon = "attacks/faerie-fire.png",
        type = "arcane",
      }
    )
    make_attack("necromancy",
      {{ 6,2},{10,2},{10,3}}, 4,
      {
        name = "EoHS_necromancy_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("chill wave"),
        icon = "attacks/iceball.png",
        type = "cold",
      }
    )
    
    if type_in("Mage,Red Mage,Arch Mage,Great Mage") then
      make_effect("resistance", { replace=true, { "resistance", { fire = 100, arcane = 100, }} })
      table.insert(default_melee_effects, {
        increase_attacks = 1,
        increase_damage  = -1 + math.max(unit.level-4, 0),
      })
    end
    if type_in("Elvish Lady,Elvish Lord,Elvish High Lord") then
      unit.cost = unit.cost + 3
      hitpoints = math.floor(0.5+hitpoints*0.9)
      --[[make_effect("attack", {
        range = "ranged",
        increase_attacks = -1,
      })]]
      if unit.level < 2 then 
        table.insert(default_melee_effects, {
          increase_damage = 2*unit.level - 5,
        })
      end
      if unit.level > 3 then 
        table.insert(default_melee_effects, {
          increase_damage = unit.level - 3,
        })
      end
    end
    if type_in("Dwarvish Runesmith,Dwarvish Runemaster,Dwarvish Arcanister") then
      unit.cost = unit.cost + 1
      hitpoints = math.floor(0.5+hitpoints*1.05)
      --[[make_effect("attack", {
        range = "ranged",
        increase_attacks = -1,
      })]]
      if unit.level < 2 then
        make_effect("resistance", { replace=true, { "resistance", { blade=80-10*unit.level, pierce=80, impact=80 }} })
        table.insert(default_melee_effects, {
          increase_damage = 3*unit.level - 8,
        })
      end
      if unit.level > 4 then 
        table.insert(default_melee_effects, {
          increase_damage = unit.level - 4,
        })
      end
    end
    if (original_type == "Troll Shaman") then
      unit.cost = unit.cost + 2
      hitpoints = math.floor(0.5+hitpoints*1.15)
      --[[make_effect("attack", {
        range = "ranged",
        increase_damage = -2,
      })]]
      table.insert(default_melee_effects, {
        increase_damage = 2*unit.level - 2,
      })
    end
    if (original_type == "Lich") then
      unit.alignment = "chaotic"
      -- Invisibility undercuts the drama of a wizard, and this usually-irrelevant ability clutters the ability list.
      make_effect("remove_ability", {
        { "abilities", EoHS.macros.ABILITY_SUBMERGE },
      })
      table.insert(default_melee_effects, {
        increase_damage = math.min(unit.level-3, 0),
      })
      --[[do
        local upgrade_array = {{1,1},{4,1},{4,2}}
        local bonus = 3
        local upgrade_total = math.min(0, unit.level - 3)
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        if unit.level > 3 then
          make_effect("attack", {
            name = "chill tempest",
            increase_damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus),
            increase_attacks = upgrade_array[upgrade_array_index][2],
          })
          make_effect("attack", {
            name = "shadow wave",
            increase_damage = math.floor((upgrade_array[upgrade_array_index][1] + excess * bonus) * 0.75),
            increase_attacks = upgrade_array[upgrade_array_index][2],
          })
        end
      end]]
    else
      unit.alignment = "neutral"
      if skills.khalifate then unit.alignment = "liminal"
      else
        if skills.military_commander and not skills.petty_necromancer  then unit.alignment = "lawful"  end
        if skills.petty_necromancer  and not skills.military_commander then unit.alignment = "chaotic" end
      end
      
      make_effect("resistance", { replace=false, { "resistance", {
        fire   = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "evocation"   ), unit.level, 4) * 10),
        cold   = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "necromancy"  ), unit.level, 4) * 10),
        arcane = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "nature_magic"), unit.level, 4) * 10),
      }} })
    end
    
    if skills.mentor then
      make_effect("resistance", { replace=false, { "resistance", {
        arcane = -40,
        fire   = -40,
        cold   = -40,
      }} })
    end
    if skills.dwarvish_alliance then
      make_effect("resistance", { replace=false, { "resistance", {
        blade  = -20,
        impact = -20,
        pierce = -20,
      }} })
    end
    if skills.traveler then
      make_effect("movement", { increase=1 })
      make_effect("defense", { replace=false, { "defense", {
        deep_water = -10,
        shallow_water = -10,
        reef = -10,
        swamp_water = -20,
        forest = skills.elvish_alliance and 0 or -10,
        sand = skills.khalifate and 0 or -10,
        frozen = -10,
      }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", {
        shallow_water = -1,
        swamp_water = -1,
        sand = -1,
        hills = -1,
        mountains = -1,
        cave = -1,
        frozen = -1,
      }} })
    end
    if skills.military_commander then
      make_effect("new_ability", { { "abilities", EoHS.abilities.leadership(unit.level) }})
    end
    if skills.rascally_friends then
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SKIRMISHER } })
    end
    if skills.khalifate then
      make_effect("defense", { replace=false, { "defense", { sand = -20, }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", { sand = -1, }} })
    end
    if skills.elvish_alliance then
      make_effect("new_ability", { { "abilities", (unit.level>2) and EoHS.macros.ABILITY_CURES or EoHS.macros.ABILITY_HEALS } })
      make_effect("defense", { replace=false, { "defense", { forest = -20, }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", { forest = -1, }} })
    end
    if skills.orcish_mercenaries then 
      table.insert(default_melee_effects, { increase_damage = 2, })
    end
    local special_ids_found = {}
    if skills.petty_necromancer and (original_type ~= "Lich") then -- I feel like Liches shouldn't default to having plague, since they don't normally
      -- hack - don't duplicate plague... TODO a better way to do this
      special_ids_found.plague = true
      table.insert(default_melee_effects, {
        set_description = (default_melee_names[1] == "staff") and wesnoth.textdomain("wesnoth-units")("plague staff") or nil,
        set_icon = "attacks/staff-plague.png", -- Won't work until 1.11
        { "set_specials", {
          mode = "append",
          EoHS.macros.WEAPON_SPECIAL_PLAGUE[1],
        }},
      })
    end
    
    if unit.alignment == "liminal" then
      make_effect("attack", {
        increase_damage = "20%",
      })
    end
    
    unit.profile = "unit_image"
    if EoHS.get_wizard_setting(unit, "can_recruit") then
      local current_recruits = {}
      for recruit in EoHS.comma_separated_values(unit.extra_recruit) do
        current_recruits[recruit] = true
      end
      local needed_recruits = {}
      local need = function(list)
        for recruit in EoHS.comma_separated_values(list) do
          table.insert(needed_recruits, recruit)
        end
      end
      if EoHS.replace_alliances_with_era then
        for i,alliance in ipairs(EoHS.skills.alliances) do
          if skills[alliance.id] then need(alliance.recruit) end
        end
      end
      if skills.military_commander then need("Cavalryman,Horseman,Spearman,Fencer,Heavy Infantryman,Bowman,Sergeant,Merman Fighter") end
      if skills.rascally_friends then need("Thief,Thug,Poacher,Footpad,Ruffian,Pirate Galleon") end
      if skills.elvish_alliance then need("Elvish Fighter,Elvish Archer,Elvish Scout,Elvish Shaman,Merman Hunter,Mermaid Initiate") end
      if skills.dwarvish_alliance then need("Dwarvish Fighter,Dwarvish Thunderer,Dwarvish Guardsman,Dwarvish Ulfserker,Dwarvish Scout") end
      if skills.dwarvish_alliance and skills.summon_gryphon then need("Gryphon Rider") end
      if skills.orcish_mercenaries then need("Orcish Grunt,Troll Whelp,Wolf Rider,Orcish Archer,Orcish Assassin,Naga Fighter,Goblin Spearman") end
      if skills.traveler then need("Saurian Skirmisher,Saurian Augur,Woodsman,Peasant,Transport Galleon") end
      if skills.petty_necromancer then need("Skeleton,Skeleton Archer,Walking Corpse,Vampire Bat,Dark Adept,Ghoul") end
      if skills.khalifate then need("Jundi,Arif,Khaiyal,Rami,Hakim,Naffat,Falcon") end
      --[[for i,recruit in ipairs(needed_recruits) do
        if not current_recruits[recruit] then
          if unit.extra_recruit == "" then
            unit.extra_recruit = recruit
          else
            unit.extra_recruit = unit.extra_recruit..","..recruit
          end
        end
      end]]
      -- Since we now have recruit removal (by becoming a lich), give up on doing the above thing to be compatible with scenario extra_recruit
      unit.extra_recruit = table.concat(needed_recruits, ",")
    end
    
    local literal_variables = EoHS.get_subtag(unit, "variables")
    local intimidate = false
    local harms_strength = 0
    local mana_income -- Aggregating the mana income bonus here is a little odd, but since we're doing all the other Soul Bind things here...
    local images
    local num_souls
    local next_extra_attack_id = 2
    -- hack - don't duplicate drains... TODO a better way to do this
    if original_type == "Lich" then special_ids_found.drains = true end
    for soul in helper.child_range(literal_variables, "EoHS_bound_soul") do
      num_souls = (num_souls or 0) + 1
      images = (images or "").."BeginSoulImage"..soul.image.."EndSoulImage"
      hitpoints = hitpoints + soul.max_hitpoints
      if soul.intimidate then intimidate = true end
      harms_strength = math.max(harms_strength, soul.harms_strength)
      if soul.mana_income then mana_income = (mana_income or 0) + soul.mana_income end
      for i,subtag in ipairs(soul) do
        if subtag[1] == "abilities" then
          make_effect("new_ability", { subtag })
        end
        if subtag[1] == "stacking_specials" then
          local set_specials_contents = EoHS.deep_copy(subtag[2])
          EoHS.remove_subtags(set_specials_contents, "*", function(s)
            local has_already = special_ids_found[s.id]
            special_ids_found[s.id] = true
            return has_already
          end)
          set_specials_contents.mode = "append"
          table.insert(default_melee_effects, {
            { "set_specials", set_specials_contents },
          })
        end
        if subtag[1] == "non_stacking_specials" then
          for i,special in ipairs(subtag[2]) do
            if not special_ids_found[special[2].id] then
              special_ids_found[special[2].id] = true
              if special[2].id == "drains" then
                -- It's always good, so put it on the default attack
                make_effect("attack", { name=default_melee_names[1], { "set_specials", { mode = "append", EoHS.macros.WEAPON_SPECIAL_DRAIN[1] } } })
              else
                for attack in helper.child_range(type_cfg, "attack") do -- TODO compatibility with extra attacks?
                  if attack.range == "melee" then
                    local new_attack = EoHS.deep_copy(attack)
                    new_attack.name = attack.name.."_"..next_extra_attack_id
                    table.insert(EoHS.force_subtag(new_attack, "specials"), special)
                    table.insert(extra_attacks, new_attack)
                    make_effect("attack", { name=new_attack.name, remove_specials="drains" })
                    table.insert(default_melee_names, new_attack.name)
                  end
                end
              end
            end
          end
        end
      end
    end
    if intimidate then
      make_effect("new_ability", { { "abilities", EoHS.abilities.intimidate(unit.level) }})
    end
    if harms_strength > 0 then
      make_effect("new_ability", { { "abilities", { {"dummy",{
        name=EoHS.substitute(_"harms -$1|", {harms_strength}),
        description=EoHS.substitute(_"At the end of this unit's turn, each adjacent enemy loses $1| HP. This can't reduce a unit's HP below 1.", {harms_strength}),
      }} }}})
      EoHS.set_unit_variable(unit, "harms_strength", harms_strength)
    else
      EoHS.set_unit_variable(unit, "harms_strength", nil)
    end
    EoHS.set_unit_variable(unit, "soul_bind_mana_income", mana_income)
    EoHS.set_unit_variable(unit, "soul_bind_images", images)
    EoHS.set_unit_variable(unit, "souls_bound", num_souls)
  end

  
  type_cfg = nil -- To make sure we don't use it after this, where it could be a bug (look at the original form explicitly if you don't want the current form)
 
  -- We don't need any stacking rules for the three type-changing spells, because:
  -- Spiritform only applies to wizards, and the others only apply to nonwizards
  -- Ogre Fury only applies to humanoids, and mudcrawlers are nonhumanoid
  -- Also, only wizards can be mounted, and you can't be mounted while in spirit form.
  
  if variables.spiritform then
    -- Overwrite most stuff, but not hitpoints
    extra_attacks = {}
    extra_effects = {}
    default_melee_effects = {}
    make_effect("movement", { increase=2 })
    unit.type = observed_type
    local spirit_cfg = EoHS.get_unit_type(unit.type)
    unit.advances_to = (spirit_cfg.advances_to == "null") and unit.type or spirit_cfg.advances_to
    
    -- TODO: aggregate the code for these and use that for all the type-changing effects
    unit.alignment = spirit_cfg.alignment
    unit.race = spirit_cfg.race
    default_melee_names = {helper.get_child(spirit_cfg, "attack").name}
  end
  
  -- TODO: Can we distribute some of these into their own files?
  if variables.touch_enchantment == "mud_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.mud_touch_special }}})
  end
  if variables.touch_enchantment == "dispelling_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.dispelling_touch_special }}})
  end
  if variables.touch_enchantment == "reanimating_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.reanimating_touch_special }}})
  end
  
  for i,effect in ipairs(default_melee_effects) do
    effect.name = table.concat(default_melee_names, ",")
    make_effect("attack", effect)
  end
  
  if variables.ogre_fury then
    extra_attacks = {}
    extra_effects = {}
    default_melee_effects = {}
    unit.level = unit.level + 1
    unit.type = (unit.level>1) and "Ogre" or "Young Ogre"
    variables.type_name_override = nil
    hitpoints = EoHS.get_unit_type(unit.type).hitpoints
    if unit.level > 2 then
      hitpoints = hitpoints + 26*(unit.level-2)
      make_effect("attack", { name = "cleaver", increase_damage = 4*(unit.level-2) })
    end
    if unit.level == 1 then
      -- Being able to make L2 Ogres from 6g Ruffians would feel unreasonable.
      -- But making L1 Young Ogres with normal stats would be very disappointing and a waste of mana/gold.
      -- So we compromise.
      hitpoints = hitpoints + 5
      make_effect("attack", { name = "cleaver", increase_damage = 3 })
    end
    unit.alignment = EoHS.get_unit_type(unit.type).alignment
    unit.race = EoHS.get_unit_type(unit.type).race
  end
  
  if variables.mud_touched then
    local movement = EoHS.get_unit_type(unit.type).movement
    for i,effect in ipairs(extra_effects) do
      if effect.apply_to == "movement" then
        if effect.set then movement = effect.set end
        if effect.increase then movement = movement + effect.increase end
      end
    end
    variables.type_name_override = nil
    if unit.level < 1 then
      unit.type = "Mudcrawler"
      extra_attacks = {}
      extra_effects = {}
      default_melee_effects = {}
    else
      local best_melee  = 0
      local best_ranged = 0
      local consider_attack = function(attack)
        attack = EoHS.deep_copy(attack)
        for i,effect in ipairs(extra_effects) do
          if (effect.apply_to == "attack") and EoHS.game_action_simulations.attack_matches_filter(attack, effect) then
            attack.damage = attack.damage + effect.increase_damage
            attack.number = attack.number + effect.increase_attacks
          end
        end
        local power = attack.damage*attack.number
        if attack.range == "melee"  then best_melee  = math.max(best_melee , power) end
        if attack.range == "ranged" then best_ranged = math.max(best_ranged, power) end
      end
      for i,attack in ipairs(EoHS.get_subtags(EoHS.get_unit_type(unit.type),"attack")) do consider_attack(attack) end
      for i,attack in ipairs(extra_attacks                                           ) do consider_attack(attack) end
      
      unit.type = "Giant Mudcrawler"
      extra_attacks = {}
      extra_effects = {}
      default_melee_effects = {}
      
      local bonus = math.floor(math.abs(best_ranged - best_melee)/3)
      -- Try to keep things equal power, given that a bonus to your weaker attack is generally less good than a penalty to your primary attack.
      if best_ranged < best_melee then
           best_ranged = best_ranged + bonus
           best_melee  = best_melee  - (bonus/2)
      else best_melee  = best_melee  + bonus
           best_ranged = best_ranged - (bonus/2) end
      -- Favor ranged, because mudcrawlers do
      best_melee  = best_melee  - 2
      best_ranged = best_ranged + 2
      local swings_bonus = ((best_ranged + best_melee) > 45) and 1 or 0
      make_effect("attack", { range = "melee" , increase_damage = math.floor(0.5 + best_melee /(2+swings_bonus))-7, increase_attacks = swings_bonus })
      make_effect("attack", { range = "ranged", increase_damage = math.floor(0.5 + best_ranged/(3+swings_bonus))-5, increase_attacks = swings_bonus })
      if unit.level > 1 then
        local size = 72 + (unit.level-1)*14
        local crop =      (unit.level-1)*5
        make_effect("image_mod", { add = "~SCALE("..size..","..size..")~CROP(0,"..crop..","..size..","..(size-crop)..")" })
      end
    end
    make_effect("movement", { set = math.floor(movement / 2) })
    unit.alignment = EoHS.get_unit_type(unit.type).alignment
    unit.race = EoHS.get_unit_type(unit.type).race
  end
  
  local needs_undead_trait = false
  if variables.is_reanimated and (unit.race ~= "undead") then
    -- TODO: fix "undead undead undead" bug
    variables.type_name_override = EoHS.substitute(_"Undead $1|", {variables.type_name_override or unit.language_name})
    needs_undead_trait = true
    unit.race = "undead"
    unit.alignment = "chaotic"
    local example = EoHS.get_unit_type_generic_example(unit.type)
    local new_resistances = EoHS.deep_copy(EoHS.get_subtag(example, "resistance"))
    local new_movement_costs = EoHS.deep_copy(EoHS.get_subtag(example, "movement_costs"))
    local new_defenses = EoHS.deep_copy(EoHS.get_subtag(example, "defense"))
    for i,effect in ipairs(extra_effects) do
      if effect.apply_to == "resistance" then
        for k,v in pairs(EoHS.get_subtag(effect, "resistance")) do
          new_resistances[k] = (effect.replace and 0 or new_resistances[k]) + v
        end
      end
    end
    
    new_defenses      .fungus      = math.max(new_defenses      .fungus      - 10, 30)
    new_defenses      .frozen      = math.max(new_defenses      .frozen      - 10, 60)
    new_movement_costs.frozen      = math.max(new_movement_costs.frozen      -  1,  2)
    new_movement_costs.swamp_water = math.max(new_movement_costs.swamp_water -  1,  2)
    if new_movement_costs.shallow_water and not new_movement_costs.deep_water then
      new_movement_costs.deep_water = new_movement_costs.shallow_water + 1
      new_defenses      .deep_water = new_defenses      .shallow_water + 10
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SUBMERGE } })
    end
    
    -- These comments were copied verbatim from the old EoHS 1.1 line, except for obvious mistakes.
    -- In general: Go for Lich-type resistances. (Lich, Ancient Lich, Death Knight, and Chocobone have those resistances at the time of this writing, with the only difference being Lich having -40% arcane instead of -50%.)
    -- A human/elf/orc/goblin should gain exact Lich resistances.
    -- Usually don't increase extreme resistances/weaknesses, because the fantasy mechanism for them is usually unrelated and non-interacting with the reason undead have these weaknesses.

    -- All existing physical undead, except the bizarre Skeletal Dragon, have either -40% or -50% arcane resistance.
    -- Decide which based on whether the unit is weak to arcane already.
    -- But don't reduce its resistance if it's already huge for some reason.
    new_resistances.arcane = math.max(new_resistances.arcane, (new_resistances.arcane > 100) and 150 or 140)

    -- All skeleton(ish) undead have -20% fire resistance. Dragons have 0%, ghouls have 10%.
    -- Leave the high fire weakness alone.
    -- Everything else does pretty much what I want if I just reduce it by 20% (cap at -20%.) Not-quite-as-fire-resistant drakes seem to make sense.
    new_resistances.fire = math.max(new_resistances.fire, math.min(120, new_resistances.fire + 20))

    -- Liches have -10% impact resist. Skeletons (including the dragon) -20%, ghouls 0%.
    -- Leave the high impact weakness alone.
    -- Units with huge impact resistance are usually that way because of attributes that SHOULDN'T change on an undead (exo-skeleton for Giant Scorpions, non-structuralness for mudcrawlers)
    -- Everything else does pretty much what I want if I just reduce it by 10% (cap at -10%.)
    new_resistances.impact = (new_resistances.impact>=50) and math.max(new_resistances.impact, math.min(110, new_resistances.impact + 10)) or new_resistances.impact

    -- Liches (and ghouls) have 10% blade resist. Skeletons (including the dragon) 40%.
    -- Leave the high blade resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 10% (cap at 40%.)
    new_resistances.blade = math.min(new_resistances.blade, math.max(60, new_resistances.blade - 10))

    -- Liches (and ghouls) have 30% pierce resist. Skeletons (including the dragon) 60%.
    -- Leave the high pierce resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 30% (cap at 60%.)
    new_resistances.pierce = math.min(new_resistances.pierce, math.max(40, new_resistances.pierce - 30))

    -- All skeleton(ish) undead have 60% cold resistance; ghouls have 40%.
    -- Leave the high cold resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 60% (cap at 60%.)
    -- 2.0 note: Changed cap to 70%, like the ghost.
    new_resistances.cold = math.min(new_resistances.cold, math.max(30, new_resistances.cold - 60))
    
    make_effect("resistance"    , { replace=true, {"resistance"    ,new_resistances   }})
    make_effect("defense"       , { replace=true, {"defense"       ,new_defenses      }})
    make_effect("movement_costs", { replace=true, {"movement_costs",new_movement_costs}})
    make_effect("image_mod"     , { add = "~CS(110,110,110)~CS(-130,-120,-110)" })
  end
  
  if variables.is_mounted then
    local mount = EoHS.get_mount(unit)
    
    local effect_movement_costs = EoHS.deep_copy(EoHS.get_subtag(mount, "movement_costs"))
    local effect_defense        = EoHS.deep_copy(EoHS.get_subtag(mount, "defense"       ))
    
    -- Hack - because non-present values don't overwrite properly
    for i,terrain in ipairs({"deep_water","shallow_water","reef","swamp_water","flat","sand","forest","hills","mountains","village","castle","cave","frozen","unwalkable","fungus"}) do
      if not effect_movement_costs[terrain] then
        effect_movement_costs[terrain] = 99
        effect_defense       [terrain] = 100
      end
    end
    
    hitpoints = hitpoints + mount.max_hitpoints
    make_effect("movement"      , { set = mount.max_moves })
    make_effect("movement_costs", { replace = true, { "movement_costs", effect_movement_costs } })
    make_effect("defense"       , { replace = true, { "defense"       , effect_defense        } })
    for attack in helper.child_range(mount, "attack") do
      attack = EoHS.deep_copy(attack)
      table.insert(EoHS.force_subtag(attack, "specials"), { "dummy", { id = "EoHS_granted_by_mount" }})
      table.insert(extra_attacks, attack)
    end
  end
  
  local type_hitpoints = EoHS.get_unit_type(unit.type).hitpoints
  if hitpoints ~= type_hitpoints then
    make_effect("hitpoints", { increase_total = hitpoints-type_hitpoints })
  end
  local type_experience = EoHS.get_unit_type(unit.type).experience
  if experience ~= type_experience then
    make_effect("max_experience", { increase = experience-type_experience })
  end
  
  for i,attack in ipairs(extra_attacks) do attack.apply_to = "new_attack"; table.insert(extra_effects_before_extra_attacks, {"effect",attack}) end
  for i,effect in ipairs(extra_effects) do table.insert(extra_effects_before_extra_attacks, effect) end
  extra_effects,extra_attacks,extra_effects_before_extra_attacks = extra_effects_before_extra_attacks,nil,nil
  extra_effects.id = "EoHS_type_adjustment_advancement"
  
  local modifications = EoHS.force_subtag(unit, "modifications")
  EoHS.remove_subtags(modifications, "advance", "EoHS_type_adjustment_advancement")
  if extra_effects[1] then
    table.insert(modifications, 1, { "advance", extra_effects }) -- advance comes before trait or object - it's fitting for type modifications
  end
  
  -- TODO can we overwrite less stuff, to increase compatibility?
  local rewritten_subtags = {attack=true,abilities=true,defense=true,resistance=true,movement_costs=true}
  EoHS.remove_subtags(unit,"*",function(val,tagname) return rewritten_subtags[tagname] end)
  unit.max_hitpoints = nil
  unit.max_experience = nil
  unit.max_moves = nil
  EoHS.get_fake_subtag(variables, "unit_attribute_memory").type = unit.type
  
  -- Wesnoth will automatically re-add these if appropriate
  EoHS.set_subtag_attribute(unit, "status.not_living")
  EoHS.remove_subtags(modifications, "trait", "undead")
  EoHS.remove_subtags(modifications, "trait", "elemental")
  EoHS.remove_subtags(modifications, "trait", "mechanical")
  -- Except for reanimated units, becuase they're not a unit type that specifies it
  if needs_undead_trait then
    table.insert(modifications, EoHS.macros.TRAIT_UNDEAD[1])
  end
  
  EoHS.shallow_overwrite(unit, EoHS.create_wunit(unit).__cfg)
  
  if EoHS.get_subtag_attribute(unit, "status.not_living") then
    EoHS.set_subtag_attribute(unit, "status.poisoned")
  end
  
  -- Has to be done after the main regeneration above
  EoHS.update_conditional_abilities(unit)
  
  if not only_a_prototype then
    EoHS.standardize_unit(unit)
    --EoHS.update_unit_graphics(unit) (standardize_unit calls it)
  end
end

EoHS.abilities = {}
EoHS.abilities.deluminates = EoHS.deep_copy(EoHS.macros.ABILITY_ILLUMINATES)
EoHS.abilities.deluminates[1][2].value = -25
EoHS.abilities.deluminates[1][2].min_value = -25
EoHS.abilities.deluminates[1][2].max_value = nil
EoHS.abilities.deluminates[1][2].name= _ "deluminates"
EoHS.abilities.deluminates[1][2].female_name= _ "female^deluminates"
EoHS.abilities.deluminates[1][2].description= _ "This unit deluminates the surrounding area, making chaotic units fight better, and lawful units fight worse.\n\nAny units adjacent to this unit will fight as if it were night when it is dusk, and as if it were dusk when it is day."
EoHS.abilities.twilight = {EoHS.deep_copy(EoHS.macros.ABILITY_ILLUMINATES[1]),EoHS.deep_copy(EoHS.abilities.deluminates[1])}
EoHS.abilities.twilight[1][2].max_value = 0
table.insert(EoHS.abilities.twilight[1][2], { "filter_base_value", { less_than = 0 }})
EoHS.abilities.twilight[2][2].min_value = 0
table.insert(EoHS.abilities.twilight[2][2], { "filter_base_value", { greater_than = 0 }})
EoHS.abilities.twilight[1][2].name= _ "twilight"
EoHS.abilities.twilight[1][2].female_name= _ "female^twilight"
EoHS.abilities.twilight[1][2].description= _ "Any units adjacent to this unit will fight as if it were twilight at all times."
EoHS.abilities.twilight[2][2].name= nil
EoHS.abilities.twilight[2][2].female_name= nil
EoHS.abilities.twilight[2][2].description= nil
EoHS.abilities.protection = {
  { "resistance", {
    id = "EoHS_protection",
    cumulative = false,
    add = 30,
    max_value = 70,
    { "filter_base_value", { less_than = 70, }},
    affect_self = false,
    { "affect_adjacent", {
      adjacent = "n,ne,se,s,sw,nw",
    }},
           name = _"protection",
    female_name = _"female^protection",
    description = _"Your adjacent units get a 30% bonus to all resistances, to a maximum of 70%.",
  }}
}
EoHS.abilities.despair = {
  { "dummy", {
    id = "EoHS_despair",
           name = _"despair",
    female_name = _"female^despair",
    description = _"All enemy units within two hexes do 30% less damage.",
  }}
}
EoHS.despair_receiver_ability = { "leadership", {
  id = "EoHS_despair_receiver",
  cumulative = true,
  value = -30,
  affect_self = true,
  { "filter", {
    lua_function = "EoHS_despair_receiver_check"
    --[[ Much too slow:
    { "filter_location", {
      radius = 2,
      { "filter", { ability = "EoHS_despair", { "filter_side", { {"enemy_of",{side="$this_unit.side"}} }} }},
      { "filter_radius", { {"not",{ terrain="_*,X*" }}, {"not",{ terrain="*^_*,*^X*" }} }}, -- TODO name this filter
    }},]]
  }},
}}
EoHS.make_filter_func("EoHS_despair_receiver_check", function(wunit)
  for i,hex in ipairs(EoHS.find_reach(wunit.x, wunit.y, EoHS.passable_only(), 2)) do
    local wunit2 = wesnoth.get_unit(hex.x, hex.y)
    if wunit2 and (not wunit2.petrified) and wesnoth.is_enemy(wunit.side, wunit2.side) and wunit2.variables.EoHS_despair_ability then return true end
  end
  return false
end)
EoHS.abilities.leadership = function(level)
  local result = {}
  for level2 = level-1,0,-1 do
    table.insert(result, { "leadership", {
      id = "leadership",
      cumulative = false,
      value = 25*(level-level2),
      affect_self = false,
      { "affect_adjacent", {
        adjacent = "n,ne,se,s,sw,nw",
        { "filter", {
          level = level2,
        }},
      }},
             name = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].name or nil,
      female_name = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].female_name or nil,
      description = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].description or nil,
    }})
  end
  return result
end
EoHS.abilities.intimidate = function(level)
  local result = {}
  for level2 = level-1,0,-1 do
    table.insert(result, { "leadership", {
      id = "EoHS_intimidate",
      cumulative = false,
      value = -15*(level-level2),
      affect_self = false,
      affect_allies = false,
      affect_enemies = true,
      { "affect_adjacent", {
        adjacent = "n,ne,se,s,sw,nw",
        { "filter", {
          level = level2,
        }},
      }},
             name = (level2==level-1) and _"intimidate" or nil,
      female_name = (level2==level-1) and _"female^intimidate" or nil,
      description = (level2==level-1) and _"Adjacent enemy units of lower level will do 15% less damage times the level difference." or nil,
    }})
  end
  return result
end

-- TODO: Maybe this should be in a different file? It's not really about unit types.
local conditional_ability_data = {}
EoHS.make_conditional_ability = function(id, func)
  table.insert(conditional_ability_data, {id="EoHS_"..id,func=func})
  conditional_ability_data["EoHS_"..id] = true
end
EoHS.update_conditional_abilities = function(unit)
  local modifications = EoHS.get_subtag(unit, "modifications")
  local abilities_tag = EoHS.get_subtag(unit, "abilities")
  if abilities_tag then EoHS.remove_subtags(abilities_tag, "*", function(a) return conditional_ability_data[a.id] end) end
  EoHS.remove_subtags(modifications, "object", "EoHS_conditional_abilities_object")
  local abilities = {}
  for i,data in ipairs(conditional_ability_data) do
    local ability = data.func(unit)
    if ability then
      ability[2].id = data.id
      if not w111 then ability[2].description = EoHS.substitute("$1|:\n$2|", {ability[2].name,ability[2].description}) end
      table.insert(abilities, ability)
      if not abilities_tag then abilities_tag = EoHS.force_subtag(unit, "abilities") end
      table.insert(abilities_tag, ability)
    end
  end
  if abilities[1] then
    table.insert(modifications, {"object",{ id="EoHS_conditional_abilities_object", {"effect",{ apply_to = "new_ability", {"abilities",abilities}}}}})
  end
  
  -- We could do this. But to be polite to add-ons that add abilities crudely, we just mess with the existing abilities tag (see above).
  -- EoHS.remove_subtags(unit, "abilities")
end

-->>)}
