this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- unit_graphics.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil


local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")

EoHS.TC_image_mod = function(side, src_colors)
  return "~TC("..wesnoth.sides[side].color..","..src_colors..")"
end

local color_index = {}
for i,entry in ipairs(wesnoth.get_variable("EoHS.wesnoth_cfgs.team_colors")) do
  if entry[1] == "color_range" then
    local r,g,b = string.match(entry[2].rgb, "^(..)(..)(..)")
    color_index[tostring(entry[2].id)] = { r=tonumber(r,16), g=tonumber(g,16), b=tonumber(b,16)}
  end
end
EoHS.TC_like_CS = function(side, channel_func)
  local rgb = color_index[wesnoth.sides[side].color]
  local r = channel_func and channel_func(rgb.r) or rgb.r
  local g = channel_func and channel_func(rgb.g) or rgb.g
  local b = channel_func and channel_func(rgb.b) or rgb.b
  return "~CS("..r..","..g..","..b..")"
end

EoHS.unit_TC_image_mod = function(unit)
  local flag_rgb = EoHS.get_unit_type(unit.type).flag_rgb
  if flag_rgb then
    return EoHS.TC_image_mod(unit.side, flag_rgb)
  else
    return ""
  end
end

local convert_square_bracket_progressive_string_syntax = function(pstring)
  pstring = string.gsub(pstring, "%[.-%]", function(group) return string.gsub(group, ",", "[") end)
  return string.gsub(pstring, "([^,]+)", function(block)
    local group_lists = {}
    for group in string.gmatch(block, "%[(.-)%]") do
      local group_list = {}
      for part in string.gmatch(group, "([^[]+)") do
        local repeated,times = string.match(part, "(.+)%*(%d+)")
        local first,last = string.match(part, "(%d+)~(%d+)")
        if repeated then for j=1,times do table.insert(group_list, repeated) end
        elseif first then
          local m,n = tonumber(first),tonumber(last)
          local pad_length = math.min(string.len(first),string.len(last))
          for j=m,n,((m<n) and 1 or -1) do
            local element_str = ""..j
            table.insert(group_list, string.rep("0",math.max(0,pad_length-string.len(element_str)))..element_str)
          end
        else table.insert(group_list, part) end
      end
      table.insert(group_lists, group_list)
    end
    if not group_lists[1] then return block end
    local image_list
    for image_num in ipairs(group_lists[1]) do
      local group_num = 0
      image_list = (image_list and image_list.."," or "")..string.gsub(block, "%[.-%]", function()
        group_num = group_num + 1
        return group_lists[group_num][image_num]
      end)
    end
    return image_list
  end)
end

EoHS.replace_progressive_images = function(progressive_image, repl_func)
  local hack_string = convert_square_bracket_progressive_string_syntax(progressive_image)
  hack_string = string.gsub(hack_string, "%b()", function(s) return string.gsub(s, ",", "[") end)
  return string.gsub(hack_string, "([^:,]+):?([^,]*)", function(s,d)
    local image = string.gsub(s, "%[", ",")
    local dur = tonumber(d)
    local force_image, force_dur = repl_func(image, dur)
    image = force_image or image
    dur = force_dur or dur
    return image..(dur and ":"..dur or "")
  end)
end

-- TODO remake these two functions by reading the actual code
EoHS.frame_duration = function(frame)
  if frame.duration then return frame.duration end
  if frame.begin and frame["end"] then return frame["end"] - frame.begin end
  local image = convert_square_bracket_progressive_string_syntax(frame.image)
  local duration = 0
  for dur in string.gmatch(image, ":(%d+)") do duration = duration + tonumber(dur) end
  return duration
end

EoHS.naive_anim_duration = function(anim)
  local duration = 0
  for i,subtag in ipairs(anim) do
    if subtag[1] == "frame" then duration = duration + EoHS.frame_duration(subtag[2]) end
    if subtag[1] == "if" then duration = duration + EoHS.naive_anim_duration(subtag[2]) end
  end
  return duration
end

--[[EoHS.unit_image_mods = function(unit, include_EoHS_unit_graphics_override)
  local image_mods = ""
  local modifications = helper.get_child(unit, "modifications")
  for i,effect in ipairs(EoHS.get_unit_effects(unit, (not include_EoHS_unit_graphics_override) and {exclude_id = "EoHS_unit_graphics_override"})) do
    if effect.apply_to == "image_mod" then
      if effect.replace then
        -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.6) uses "RC()" when it should use "~RC()"
        if string.sub(effect.replace, 1, 1) ~= "~" then effect.replace = "~"..effect.replace end
        image_mods = effect.replace
      end
      if effect.add then
        -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.6) uses "RC()" when it should use "~RC()"
        if string.sub(effect.add, 1, 1) ~= "~" then effect.add = "~"..effect.add end
        image_mods = image_mods..effect.add
      end
    end
  end
  image_mods = image_mods..EoHS.unit_TC_image_mod(unit)
  return image_mods
end]]

--[[

function(get_val)

  return result
end


get_val_impl = function(path) return something end




local delimiter = "EoHS_mgc_delim"
local memoized_graphics_component = function(id, func)
  return function(context, args)
    local cached_result = basic_get_val_func(id.."_cached_result_"..args)
    if cached_result then
      local access_number = 1
      while true do
        local path = basic_get_val_func(id.."_access_path_"..args..access_number)
        if not path then break end
        local value_found = basic_get_val_func(id.."_access_val_"..args..access_number)
        if get_val_impl(path) ~= value_found then recompute = true; break end
        access_number = access_number + 1
      end
      if not recompute then return cached_result end
    end
    local access_number = 1
    local new_result = func(function(path)
      local found = basic_get_val_func(path)
      basic_set_val_func(id.."_access_path_"..args..access_number, path)
      basic_set_val_func(id.."_access_val_"..args..access_number, found)
      return found
    end, function(callee, args2)
      local result = callee(basic_get_val, basic_set_val, args2)
    end, args)
    basic_set_val_func(id.."_cached_result_"..args, new_result)
    return new_result
  end
end


local = function(id, func)
  return function(context, ...)
    context.call_stack_head = { parent = context.call_stack_head, id_and_args=id..serialize{...}, }
    func(context, ...)
    context.call_stack_head = context.call_stack_head.parent
  end
end

= function(basic_get_val, total_func, ...)
  local values_by_path_accessed = {}
  local funcs_by_path_accessed = {}
  local context
  context = {
    call_stack_head = nil
    get_val = function(path)
      local cached = values_by_path_accessed[path]
      if not cached then
        cached = basic_get_val(path)
        values_by_path_accessed[path] = cached
      end
      local stack_member = context.call_stack_head
      while stack_member do
        funcs_by_path_accessed[path][stack_member.id_and_args] = true
        stack_member = stack_member.parent
      end
      return cached
    end,
  }
  local total_result = total_func(context, ...)
  return total_result, 
end

local foo = memoized_graphics_component("foo", function(get_func, call_func, args)
  
end)




local memoized_graphics_component = function(func)
  return function()
    func(function(path)
      local found = basic_get_val_func(path)
      
    end)
  end
end



]]




do
  local wizard_casting_image_bases_table = {
    [      "Mage"] = {"units/human-magi/mage+female-attack-magic1.png"       , "units/human-magi/mage+female-attack-magic2.png"       },
    [  "Red Mage"] = {"units/human-magi/red-mage+female-attack-magic-1.png"  , "units/human-magi/red-mage+female-attack-magic-2.png"  },
    [ "Arch Mage"] = {"units/human-magi/arch-mage+female-attack-magic-1.png" , "units/human-magi/arch-mage+female-attack-magic-2.png" },
    ["Great Mage"] = {"units/human-magi/great-mage+female-attack-magic-1.png", "units/human-magi/great-mage+female-attack-magic-2.png"},
    [      "Lich"] = {"units/undead-necromancers/lich-magic-1.png"           , "units/undead-necromancers/lich-magic-3.png"           },
    [      "Elvish Lord"] = {"units/elves-wood/lord-magic.png"           , "units/elves-wood/lord-magic-1.png"           },
    [      "Elvish High Lord"] = {"units/elves-wood/high-lord-magic.png"           , "units/elves-wood/high-lord-magic-1.png"           },
    [      "Dwarvish Runesmith"] = {"units/dwarves/runesmith-attack-se-2.png"           , "units/dwarves/runesmith-attack-se-3.png"           },
    [      "Troll Shaman"] = {"units/trolls/shaman-ranged-1.png"           , "units/trolls/shaman-ranged-3.png"           },
  }
  EoHS.wizard_casting_image_base = function(unit, frame_number)
    local table_entry = wizard_casting_image_bases_table[unit.type]
    local image_base = table_entry and table_entry[frame_number] or unit.image
    if unit.gender ~= "female" then
      return (string.gsub(image_base, "+female", "")) -- strip gsub's extra return value
    end
    return image_base
  end
end

do
  local weapon_head_offsets_table = {
    ["units/undead-necromancers/lich.png"             ] = { x = 36-11, y = 36-22 },
    ["units/undead-necromancers/lich-magic-1.png"     ] = { x = 36-12, y = 36-25 },
    ["units/undead-necromancers/lich-magic-2.png"     ] = { x = 36-14, y = 36-26 },
    ["units/undead-necromancers/lich-magic-3.png"     ] = { x = 36-15, y = 36-28 },
    ["units/undead-necromancers/lich-defend.png"      ] = { x = 36-15, y = 36-24 },
    ["units/undead-necromancers/lich-idle-1.png"      ] = { x = 36-11, y = 36-23 },
    ["units/undead-necromancers/lich-idle-2.png"      ] = { x = 36-11, y = 36-23 },
    ["units/undead-necromancers/lich-idle-3.png"      ] = { x = 36-11, y = 36-23 },
    ["units/undead-necromancers/lich-melee-1.png"     ] = { x = 36- 7, y = 36-26 },
    ["units/undead-necromancers/lich-melee-2.png"     ] = { x = 36- 5, y = 36-26 },
    ["units/human-magi/mage.png"                      ] = { x = 36+15, y = 36-14 },
    ["units/human-magi/mage-attack-magic1.png"        ] = { x = 36+14, y = 36-16 },
    ["units/human-magi/mage-attack-magic2.png"        ] = { x = 36+ 9, y = 36-21 },
    ["units/human-magi/mage-attack-staff1.png"        ] = { x = 36+ 8, y = 36-24 },
    ["units/human-magi/mage-attack-staff2.png"        ] = { x = 36+27, y = 36+10 },
    ["units/human-magi/mage-defend.png"               ] = { x = 36+12, y = 36-15 },
    ["units/human-magi/red-mage.png"                  ] = { x = 36+14, y = 36-11 },
    ["units/human-magi/red-mage-attack-magic-1.png"   ] = { x = 36+13, y = 36-18 },
    ["units/human-magi/red-mage-attack-magic-2.png"   ] = { x = 36+11, y = 36-23 },
    ["units/human-magi/red-mage-attack-staff-1.png"   ] = { x = 36+10, y = 36-23 },
    ["units/human-magi/red-mage-attack-staff-2.png"   ] = { x = 36+28, y = 36+ 9 },
    ["units/human-magi/red-mage-defend.png"           ] = { x = 36+14, y = 36-17 },
    ["units/human-magi/arch-mage.png"                 ] = { x = 36+16, y = 36-18 },
    ["units/human-magi/arch-mage-attack-magic-1.png"  ] = { x = 36+17, y = 36-21 },
    ["units/human-magi/arch-mage-attack-magic-2.png"  ] = { x = 36+18, y = 36-24 },
    ["units/human-magi/arch-mage-attack-staff-1.png"  ] = { x = 36+ 6, y = 36-30 },
    ["units/human-magi/arch-mage-attack-staff-2.png"  ] = { x = 36+30, y = 36+10 },
    ["units/human-magi/arch-mage-defend.png"          ] = { x = 36+13, y = 36-19 },
    ["units/human-magi/great-mage.png"                ] = { x = 36+17, y = 36-26 },
    ["units/human-magi/great-mage-attack-magic-1.png" ] = { x = 36+17, y = 36-28 },
    ["units/human-magi/great-mage-attack-magic-2.png" ] = { x = 36+18, y = 36-31 },
    ["units/human-magi/great-mage-attack-staff-1.png" ] = { x = 36+ 3, y = 36-33 },
    ["units/human-magi/great-mage-attack-staff-2.png" ] = { x = 36+32, y = 36+10 },
    ["units/human-magi/great-mage-defend.png"         ] = { x = 36+12, y = 36-27 },
    ["units/undead/wraith-s.png"                      ] = { x = 36+ 8, y = 36+ 5 },
    ["units/undead/wraith-s-1.png"                    ] = { x = 36+ 8, y = 36+ 5 },
    ["units/undead/wraith-s-2.png"                    ] = { x = 36+ 8, y = 36+ 5 },
    ["units/undead/wraith-s-3.png"                    ] = { x = 36+ 7, y = 36+ 4 },
    ["units/undead/wraith-s-4.png"                    ] = { x = 36+ 7, y = 36+ 5 },
    ["units/undead/wraith-s-defend-1.png"             ] = { x = 36+ 7, y = 36+ 3 },
    ["units/undead/wraith-s-defend-2.png"             ] = { x = 36+ 6, y = 36+ 2 },
    ["units/undead/wraith-s-attack-1.png"             ] = { x = 36+ 6, y = 36+ 1 },
    ["units/undead/wraith-s-attack-2.png"             ] = { x = 36+ 0, y = 36+10 },
    ["units/undead/wraith-s-attack-3.png"             ] = { x = 36+14, y = 36- 6 },
    ["units/undead/wraith-s-attack-4.png"             ] = { x = 36+14, y = 36- 6 },
    ["units/undead/wraith-s-attack-5.png"             ] = { x = 36+15, y = 36- 7 },
    ["units/elves-wood/lady.png"             ] = { x = 45, y = 41 },
    ["units/elves-wood/lord.png"             ] = { x = 46, y = 39 },
    ["units/elves-wood/lord-defend.png"             ] = { x = 45, y = 38 },
    ["units/elves-wood/lord-melee.png"             ] = { x = 44, y = 35 },
    ["units/elves-wood/lord-magic.png"             ] = { x = 25, y = 38 },
    ["units/elves-wood/lord-magic-1.png"             ] = { x = 17, y = 23 },
    ["units/elves-wood/lord-magic-defend.png"             ] = { x = 25, y = 38 },
    ["units/elves-wood/high-lord.png"             ] = { x = 19, y = 39 },
    ["units/elves-wood/high-lord-attack-sword-1.png"             ] = { x = 42, y = 21 },
    ["units/elves-wood/high-lord-attack-sword-2.png"             ] = { x = 42, y = 46 },
    ["units/elves-wood/high-lord-defend-1.png"             ] = { x = 31, y = 34 },
    ["units/elves-wood/high-lord-defend-2.png"             ] = { x = 39, y = 33 },
    ["units/elves-wood/high-lord-magic.png"             ] = { x = 19, y = 39 },
    ["units/elves-wood/high-lord-magic-1.png"             ] = { x = 17, y = 22 },
    ["units/elves-wood/high-lord-magic-defend.png"             ] = { x = 19, y = 39 },
    ["units/dwarves/arcanister.png"             ] = { x = 18, y = 30 },
    ["units/dwarves/runemaster.png"             ] = { x = 18, y = 34 },
    ["units/dwarves/runesmith.png"             ] = { x = 20, y = 36 },
    ["units/dwarves/runesmith-attack-se-1.png"             ] = { x = 20, y = 33 },
    ["units/dwarves/runesmith-attack-se-2.png"             ] = { x = 14, y = 38 },
    ["units/dwarves/runesmith-attack-se-3.png"             ] = { x = 17, y = 48 },
    ["units/dwarves/runesmith-attack-se-4.png"             ] = { x = 18, y = 41 },
    ["units/dwarves/runesmith-attack-se-5.png"             ] = { x = 29, y = 63 },
    ["units/dwarves/runesmith-attack-se-6.png"             ] = { x = 76, y = 42 },
    ["units/dwarves/runesmith-attack-se-7.png"             ] = { x = 72, y = 40 },
    ["units/dwarves/runesmith-attack-se-8.png"             ] = { x = 68, y = 49 },
    ["units/dwarves/runesmith-attack-se-9.png"             ] = { x = 56, y = 50 },
    ["units/dwarves/runesmith-attack-se-10.png"             ] = { x = 39, y = 49 },
    ["units/dwarves/runesmith-defend-1.png"             ] = { x = 24, y = 38 },
    ["units/dwarves/runesmith-defend-2.png"             ] = { x = 32, y = 40 },
    ["units/trolls/shaman.png"             ] = { x = 26, y = 44 },
    ["units/trolls/shaman-defend-1.png"             ] = { x = 34, y = 36 },
    ["units/trolls/shaman-defend-2.png"             ] = { x = 30, y = 29 },
    ["units/trolls/shaman-fist-1.png"             ] = { x = 22, y = 31 },
    ["units/trolls/shaman-fist-2.png"             ] = { x = 32, y = 15 },
    ["units/trolls/shaman-fist-3.png"             ] = { x = 58, y = 35 },
    ["units/trolls/shaman-fist-4.png"             ] = { x = 48, y = 39 },
    ["units/trolls/shaman-fist-5.png"             ] = { x = 36, y = 37 },
    ["units/trolls/shaman-ranged-1.png"             ] = { x = 34, y = 38 },
    ["units/trolls/shaman-ranged-2.png"             ] = { x = 30, y = 42 },
    ["units/trolls/shaman-ranged-3.png"             ] = { x = 23, y = 41 },
    -- TODO shadows
  }
  EoHS.weapon_head_offset = function(image_layer_or_unit_graphics)
    if image_layer_or_unit_graphics.main_layer then image_layer_or_unit_graphics = image_layer_or_unit_graphics.main_layer end
  -- EoHS.err("w")
    local relevant_image_name = string.gsub(EoHS.get_image_base(image_layer_or_unit_graphics), "+female", "")
    local result = EoHS.deep_copy(weapon_head_offsets_table[relevant_image_name])
    if not result then
      if string.find(relevant_image_name, "spectre") then result = { x=55, y=23 }
      else return EoHS.image_layer_offset(image_layer_or_unit_graphics) end
    end
    result = EoHS.offset_relative_to_base_image(result, image_layer_or_unit_graphics)
    return result
  end
end

EoHS.rider_mountpoint_offset = function(image_layer_or_unit_graphics)
  if image_layer_or_unit_graphics.main_layer then image_layer_or_unit_graphics = image_layer_or_unit_graphics.main_layer end
  -- EoHS.err("g")
  local relevant_image_name = string.gsub(EoHS.get_image_base(image_layer_or_unit_graphics), "+female", "")
  local result
      if string.match(relevant_image_name, "deathknight%-crossbow") then result = { x = 36- 5, y = 36+12 }
  elseif string.match(relevant_image_name, "deathknight"          ) then result = { x = 36- 4, y = 36+ 4 }
  elseif string.match(relevant_image_name,           "great%-mage") then result = { x = 36, y = 43 }
  elseif string.match(relevant_image_name,            "arch%-mage") then result = { x = 36, y = 41 }
  elseif string.match(relevant_image_name,             "red%-mage") then result = { x = 33, y = 41 }
  elseif string.match(relevant_image_name,                  "mage") then result = { x = 34, y = 42 }
  elseif string.match(relevant_image_name,                  "lich") then result = { x = 36+ 2, y = 36+ 4 }
  elseif string.match(relevant_image_name,             "wood/lady") then result = { x = 38, y = 41 }
  elseif string.match(relevant_image_name,             "wood/lord") then result = { x = 31, y = 43 }
  elseif string.match(relevant_image_name,       "wood/high%-lord") then result = { x = 32, y = 41 }
  elseif string.match(relevant_image_name,            "arcanister") then result = { x = 38, y = 47 }
  elseif string.match(relevant_image_name,            "runemaster") then result = { x = 38, y = 47 }
  elseif string.match(relevant_image_name,             "runesmith") then result = { x = 38, y = 47 }
  elseif string.match(relevant_image_name,         "trolls/shaman") then result = { x = 35, y = 44 }
  end
  if not result then
    return EoHS.image_layer_offset(image_layer_or_unit_graphics)
  end
  result = EoHS.offset_relative_to_base_image(result, image_layer_or_unit_graphics)
  return result
end

-- TODO: refine these by implementing a way to tweak them while looking at them in-game
do
  local mount_mountpoints_table = {
    ["units/monsters/water-serpent.png"            ] = { x=30, y=47 },
    ["units/monsters/water-serpent-n.png"          ] = { x=35, y=41 },
    ["units/monsters/gryphon.png"                  ] = { x =  41, y =  34 },
    ["units/monsters/gryphon-flying-1.png"         ] = { x =  65, y = 60- 5 },
    ["units/monsters/gryphon-flying-2.png"         ] = { x =  65, y = 60- 8 },
    ["units/monsters/gryphon-flying-3.png"         ] = { x =  65, y = 60-10 },
    ["units/monsters/gryphon-flying-4.png"         ] = { x =  65, y = 60-14 },
    ["units/monsters/gryphon-flying-5.png"         ] = { x =  65, y = 60-12 },
    ["units/monsters/gryphon-flying-6.png"         ] = { x =  65, y = 60- 9 },
    ["units/monsters/gryphon-flying-7.png"         ] = { x =  65, y = 60- 6 },
    ["units/monsters/gryphon-flying-8.png"         ] = { x =  65, y = 60- 3 },
    ["units/monsters/fire-dragon.png"              ] = { x = 114, y =  71 },
    ["units/monsters/skeletal-dragon.png"          ] = { x = 42, y =  23 }, -- 1.10
    ["units/monsters/skeletal-dragon/skeletal-dragon.png"] = { x = 118, y =  74 }, -- 1.11
    ["units/undead-skeletal/chocobone.png"         ] = { x = 36- 5, y = 36- 2 },
    ["units/undead-skeletal/chocobone-defend-2.png"] = { x = 36-14, y = 36 },
    ["units/undead-skeletal/chocobone-defend-1.png"] = { x = 36-12, y = 36- 2 },
    ["units/undead-skeletal/chocobone-attack-1.png"] = { x = 36- 7, y = 36 },
    ["units/undead-skeletal/chocobone-attack-2.png"] = { x = 36- 8, y = 36 },
    ["units/undead-skeletal/chocobone-attack-3.png"] = { x = 36- 3, y = 36- 1 },
    ["units/undead-skeletal/chocobone-attack-4.png"] = { x = 36- 8, y = 36 },
  }
  local wolf_aux = {
    ["units/monsters/wolf.png"                    ] = { x = 37, y = 36- 7 },
    ["units/monsters/wolf-water.png"              ] = { x = 37, y = 36- 7 },
    ["units/monsters/wolf-moving.png"             ] = { x = 38, y = 36- 5 },
    ["units/monsters/wolf-attack.png"             ] = { x = 43, y = 36- 9 },
    ["units/monsters/wolf-defend-1.png"           ] = { x = 35, y = 36+ 0 },
    ["units/monsters/wolf-defend-2.png"           ] = { x = 37, y = 36- 4 },
  }
  for k,v in pairs(wolf_aux) do
    local gwolf_name = string.gsub(k, "wolf", "wolf-great")
    local dwolf_name = string.gsub(k, "wolf", "direwolf")
    
    mount_mountpoints_table[k] = EoHS.deep_copy(v)
    
    mount_mountpoints_table[gwolf_name] = EoHS.deep_copy(v)
    mount_mountpoints_table[gwolf_name].y = v.y - 5
    
    mount_mountpoints_table[dwolf_name] = EoHS.deep_copy(v)
    mount_mountpoints_table[dwolf_name].y = v.y - 6
  end
  if w111 then
    mount_mountpoints_table["units/monsters/seaserpent.png"] = { x = 23, y = 33 }
  else
    mount_mountpoints_table["units/monsters/seaserpent-attack.png"] = { x = 31, y = 31 }
    mount_mountpoints_table["units/monsters/seaserpent-defend.png"] = { x = 31, y = 31 }
  end
  
  EoHS.mount_mountpoint_offset = function(image_layer_or_unit_graphics)
    if image_layer_or_unit_graphics.main_layer then image_layer_or_unit_graphics = image_layer_or_unit_graphics.main_layer end
  -- EoHS.err("s")
    local relevant_image_name = EoHS.get_image_base(image_layer_or_unit_graphics)
    local result = EoHS.deep_copy(mount_mountpoints_table[relevant_image_name])
    if not result then
      if string.find(relevant_image_name, "mudcrawler") then result = { x=36- 1, y=36- 7 }
      elseif string.find(relevant_image_name, "water%-serpent%-n") then result = EoHS.deep_copy(mount_mountpoints_table["units/monsters/water-serpent-n.png"])
      elseif string.find(relevant_image_name, "water%-serpent")    then result = EoHS.deep_copy(mount_mountpoints_table["units/monsters/water-serpent.png"  ])
      else return EoHS.image_layer_offset(image_layer_or_unit_graphics) end
    end
    result = EoHS.offset_relative_to_base_image(result, image_layer_or_unit_graphics)
    return result
  end
end

local unit_graphics_aggregate = function(unit_graphics)
  return EoHS.image_aggregates_combined(unit_graphics.underlays, unit_graphics.main_layer_eviscerated or unit_graphics.main_layer, unit_graphics.overlays)
end
local translate_unit_graphics = function(unit_graphics, offset)
  unit_graphics.underlays  = EoHS.image_aggregate_translated(unit_graphics.underlays , offset)
  unit_graphics.main_layer = EoHS.image_aggregate_translated(unit_graphics.main_layer, offset)
  unit_graphics.overlays   = EoHS.image_aggregate_translated(unit_graphics.overlays  , offset)
  unit_graphics.main_layer_eviscerated = unit_graphics.main_layer_eviscerated and EoHS.image_aggregate_translated(unit_graphics.main_layer_eviscerated, offset)
end

local simple_unit_graphics = function(main_layer) return { underlays = {}, main_layer = main_layer, overlays = {} } end

--[[local unit_graphics_serialized = function(unit_graphics)
  return "_EoHSUnitGraphicsUnderlays_"..EoHS.image_aggregate_serialized(unit_graphics.underlays)..
         "_EoHSUnitGraphicsOverlays_"..EoHS.image_aggregate_serialized(unit_graphics.overlays)..
         "_EoHSUnitGraphicsMainLayer_"..EoHS.image_aggregate_serialized(unit_graphics.main_layer)..
         "_EoHSUnitGraphicsMainLayerEviscerated_"..(unit_graphics.main_layer_eviscerated and EoHS.image_aggregate_serialized(unit_graphics.main_layer_eviscerated) or "")
end

local unit_graphics_deserialized = function(unit_graphics_str)
  local a,b,c,d = string.match(unit_graphics_str, "_EoHSUnitGraphicsUnderlays_(.-)_EoHSUnitGraphicsOverlays_(.-)_EoHSUnitGraphicsMainLayer_(.-)_EoHSUnitGraphicsMainLayerEviscerated_(.*)")
  return {
    underlays = EoHS.image_aggregate_deserialized(a),
    overlays = EoHS.image_aggregate_deserialized(b),
    main_layer = EoHS.image_aggregate_deserialized(c),
    main_layer_eviscerated = (d ~= "") and EoHS.image_aggregate_deserialized(d),
  }
end]]

local is_chocobone_knight = function(variables) return variables.is_summon and (EoHS.get_fake_subtag(variables, "unit_attribute_memory").type == "Death Knight") end
local make_unit_graphics_ignoring_mount = EoHS.caching_func(function(variables, main_layer)
  EoHS.assert(main_layer, "make_unit_graphics_ignoring_mount with no main layer")
  local result = simple_unit_graphics(main_layer)
  local underlay = function(...)
    result.underlays = EoHS.image_aggregate_destructive_combine(result.underlays, ...)
  end
  local overlay = function(...)
    result.overlays = EoHS.image_aggregate_destructive_combine(result.overlays, ...)
  end
  
  local weapon_head_offset = EoHS.weapon_head_offset(main_layer)
  
  if not is_chocobone_knight(variables) then
    result.main_layer = EoHS.image_aggregate_modded(result.main_layer, variables.image_mods)
    if variables.is_wizard then
      result.main_layer_eviscerated = EoHS.dressed_up_unit_image_aggregate(result.main_layer, EoHS.get_fake_subtag(variables, "dress_up_options"))
    end
  end

  if variables.dark_pact then
    -- Blurring has weird effects with the cropped pieces, so collapse it first
    underlay(EoHS.image_aggregate_modded(EoHS.collapse_image_aggregate("image_layer", result.main_layer_eviscerated or result.main_layer), "~BL(2)~CS(-255,-255,-255)~O(5)"))
  end
  if variables.rampage then
    overlay(EoHS.image_aggregate_modded(EoHS.collapse_image_aggregate("image_layer", result.main_layer_eviscerated or result.main_layer), "~O(0.4)~CS(255,255,-255)~G(-127)~BL(5)"))
  end
  if variables.curse_of_anxiety_turns then
    overlay{ image_modded = "projectiles/wailprojectile-ne-3.png~O(0.8)"          , offset = { x =  11, y = -9 } }
    overlay{ image_modded = "projectiles/wailprojectile-ne-3.png~O(0.8)~FL(horiz)", offset = { x = -11, y = -9 } }
  end
  if variables.lightning_paralysis then
    overlay("projectiles/gaze.png")
  end
  if variables.wizard_sword_turns then
    overlay("items/sword.png")
  end
  if variables.touch_enchantment == "dispelling_touch" then
    overlay{ image_modded = "halo/elven/ice-halo5.png", offset = EoHS.deep_copy(weapon_head_offset) }
  end
  if variables.touch_enchantment == "reanimating_touch" then
    --overlay{ image_modded = "projectiles/darkmissile-ne.png~CROP(16,16,40,40)", offset = EoHS.deep_copy(weapon_head_offset) }
    overlay{ image_modded = "halo/undead/dark-magic-3.png~CROP(10,0,46,44)", offset = EoHS.deep_copy(weapon_head_offset) }
  end
  if variables.touch_enchantment == "mud_touch" then
    overlay{ image_modded = "projectiles/mud-glob.png~CROP(26,25,19,19)", offset = EoHS.deep_copy(weapon_head_offset) }
  end
  if variables.regeneration_turns then
    overlay("halo/elven/nature-halo6.png")
  end
  if variables.just_teleported_ally then
    overlay("footsteps/teleport-in.png~O(0.5)")
  end
  if variables.just_teleported_enemy then
    overlay("footsteps/teleport-in.png~O(0.5)~CS(40,150,-80)")
  end

  return result
end)

local mount_underlays_and_overlays_cache = {}
local assemble_mount_and_rider = function(mount_graphics, rider_graphics)
  local mount_graphics_serialized = EoHS.get_image_modded(mount_graphics.main_layer) --hack, TODO better...? --EoHS.serialize(mount_graphics)
  local mount_mountpoint_offset = EoHS.mount_mountpoint_offset(mount_graphics)
  local rider_mountpoint_offset = EoHS.rider_mountpoint_offset(rider_graphics)
  local rider_offset = EoHS.offset_translated(mount_mountpoint_offset, EoHS.offset_negated(rider_mountpoint_offset))
  
  local result = EoHS.deep_copy(rider_graphics)
  translate_unit_graphics(result, rider_offset)
  
  local mount_image_aggregate = unit_graphics_aggregate(mount_graphics)
  -- Flatten so that cropping doesn't create an excessive amount of layers.
  -- local mount_image_modded = EoHS.collapse_image_aggregate("image_layer", EoHS.unit_graphics_aggregate(mount_graphics))
  local mount_image_base = EoHS.get_image_base(mount_graphics.main_layer)
  
  local underlay_overlay = function(lays_func)
    local cached = mount_underlays_and_overlays_cache[mount_graphics_serialized]
    if not cached then
      local under, over = lays_func()
      mount_underlays_and_overlays_cache[mount_graphics_serialized] = { under, over }
      cached = mount_underlays_and_overlays_cache[mount_graphics_serialized]
      
      -- EoHS.err("Lays: "..EoHS.inspect(lays))
    end
    result.underlays = EoHS.image_aggregates_combined(cached[1], result.underlays)
    result.overlays = EoHS.image_aggregate_destructive_combine(result.overlays, cached[2])
  end
  
  -- EoHS.err("l")
  local l = function(c)
    c.relative_to_base_image = mount_image_base
    return c
  end
  if mount_image_base == "units/monsters/fire-dragon.png" then
    underlay_overlay(function()
      local top = EoHS.image_aggregate_cropped(mount_image_aggregate, l{ y2 = 108 })
      return mount_image_aggregate, EoHS.image_aggregate_sampled(top,
        { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y, },
        l{ x=108, y1=53, y2=55, },
        l{ x=109, y1=53, y2=57, },
        l{ x=110, y1=54, y2=58, },
        l{ x=111, y1=55, y2=60, },
        l{ x=112, y1=56, y2=61, },
        l{ x=113, y1=57, y2=67, },
        l{ x=114, y1=58, y2=68, },
        l{ x=115, y1=58, y2=69, },
        l{ x=116, y1=59, },
        l{ x=117, y1=60, },
        l{ x=118, y1=61, },
        l{ x=119, y1=62, },
        l{ x1=120, x2=122, y1=63, },
        l{ x1=123, y1=64, },
        l{ x1=125, y1=49, }--[[,
        l{ x=108, y1=71, y2=75, },
        l{ x=109, y1=70, },
        l{ x=110, y1=71, },
        l{ x1=111, y1=72, }]])
    end)
  elseif string.find(mount_image_base, "water%-serpent%-attack") then
    -- Riding during a lunge would be unrealistic AND I can't draw it nicely. Temporarily appear to dismount.
    if string.find(mount_image_base, "water%-serpent%-attack%-s%-") then
      underlay_overlay(function() return {}, mount_image_aggregate end)
    else
      underlay_overlay(function() return mount_image_aggregate, {} end)
    end
  elseif mount_image_base == "units/monsters/water-serpent-n.png" then
    underlay_overlay(function()
      return EoHS.image_aggregate_cropped(mount_image_aggregate, {y2 = 45}), EoHS.image_aggregate_sampled(mount_image_aggregate,
        { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y },
        l{ x1 = 36, },
        l{ y1 = 42, x2 = 23 },
        l{ y1 = 43, x1 = 22, x2 = 25, },
        l{ y1 = 44, x1 = 26, x2 = 28, },
        l{ y1 = 45, x1 = 29, x2 = 33, },
        l{ y1 = 46, x1 = 34, })
    end)
  elseif mount_image_base == "units/monsters/water-serpent.png" then
    underlay_overlay(function()
      local left, right = EoHS.image_aggregate_split(mount_image_aggregate, { x1 = mount_mountpoint_offset.x })
      local top, bot = EoHS.image_aggregate_split(right, l{ y1 = 48 })
      local under, over = EoHS.image_aggregate_split(top, l{ x1 = 30, y1 = 47, x2 = 37 },
        l{ y1 = 47, x1 = 42, },
        l{ y1 = 46, x1 = 44, },
        l{ x1 = 45, },
        l{ x1 = 38, y2 = 39, })
      return EoHS.image_aggregates_combined(left, under), EoHS.image_aggregates_combined(bot, over)
    end)
  elseif string.find(mount_image_base, "chocobone") then
    underlay_overlay(function()
      return EoHS.image_aggregate_split(mount_image_aggregate, { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y }, { x1 = 6 })
    end)
  elseif string.find(mount_image_base, "seaserpent") then
    if w111 then
      underlay_overlay(function()
        return EoHS.image_aggregate_split(mount_image_aggregate, { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y },
          l{ x1 = 26, y1=0, y2=19 }, l{ x1 = 30, y1=20, y2=32 })
      end)
    else
      underlay_overlay(function()
        return EoHS.image_aggregate_split(mount_image_aggregate, { x1 = mount_mountpoint_offset.x }, { x1 = 29, y1=31, x2=30, y2=36 })
      end)
    end
  else
    underlay_overlay(function()
      return EoHS.image_aggregate_split(mount_image_aggregate, { x1 = mount_mountpoint_offset.x, y1 = mount_mountpoint_offset.y })
    end)
  end
  
  return result
end

EoHS.mount_default_main_layer = function(mount_type, anim)
  if (mount_type == "Sea Serpent") and not w111 then return "units/monsters/seaserpent-defend.png" end
  if anim then
    if mount_type == "Water Serpent" then
      if anim.direction and string.match(anim.direction, "n") then
        return "units/monsters/water-serpent-n.png"
      end
    end
    if EoHS.anim_applies_to(anim, "attack") or EoHS.anim_applies_to(anim, "movement") then
          if mount_type ==       "Wolf" then return "units/monsters/wolf-moving.png"
      elseif mount_type == "Great Wolf" then return "units/monsters/wolf-great-moving.png"
      elseif mount_type ==   "Direwolf" then return "units/monsters/direwolf-moving.png"
      elseif mount_type ==    "Gryphon" then return "units/monsters/gryphon-flying-4.png"
      elseif mount_type ==  "Chocobone" then return "units/undead-skeletal/chocobone-attack-1.png"
      end
    end
  end
  -- TODO: combine defense anims
  return EoHS.get_unit_type(mount_type).image --.."~O(0.5)"
end

local haste_modded = function(image_modded)
  local extents = EoHS.image_aggregate_extents(image_modded)
  return image_modded.."~SCALE("..extents.size.x..","..(extents.size.y*3)..")~BL(1)~SCALE("..extents.size.x..","..extents.size.y..")"
end

-- TODO make palettes part of image format
local assemble_one_frame_impl = EoHS.caching_func(function(variables, main_layer, mount_layer)
  EoHS.assert(main_layer, "assemble_one_frame_impl with no main layer")
  if is_chocobone_knight(variables) then
    main_layer = EoHS.collapse_image_aggregate("image_layer",
      EoHS.image_aggregate_modded(
        unit_graphics_aggregate(assemble_mount_and_rider(simple_unit_graphics(mount_layer), simple_unit_graphics(main_layer))),
        variables.image_mods))
  end
  local graphics_ignoring_mount = make_unit_graphics_ignoring_mount(variables, main_layer)
  local result
  if variables.is_mounted then
    result = assemble_mount_and_rider(simple_unit_graphics(EoHS.image_aggregate_modded(mount_layer, variables.mount_image_mods)), graphics_ignoring_mount)
  else
    result = EoHS.deep_copy(graphics_ignoring_mount)
  end
  
  --[[if variables.haste_turns then
    result.main_layer = haste_modded(EoHS.collapse_image_aggregate("image_modded", result.main_layer_eviscerated or result.main_layer))
    result.main_layer_eviscerated = nil
  end]]
  
  local shields = variables.mage_shields
  if shields and (shields > 0) then
    local extents = EoHS.image_aggregate_extents(unit_graphics_aggregate(result))
    local size = math.ceil(math.max(extents.size.x, extents.size.y) * 160 / 72)
    result.overlays = EoHS.image_aggregate_destructive_combine(result.overlays, {
      image_modded = "halo/elven/elven-shield-halo-100pct.png~O("..((shields + 1) / 3)..")~SCALE("..size..","..size..")",
      offset = extents.offset,
    })
  end

  return result
end)

local assemble_one_frame = function(variables, main_layer, mount_layer, anim)
  if variables.is_crypt then main_layer = "scenery/mausoleum01.png" end
  if variables.is_mounted or is_chocobone_knight(variables) then
    if not main_layer then main_layer = EoHS.get_fake_subtag(variables, "unit_attribute_memory").image end
    if not mount_layer then 
      if is_chocobone_knight(variables) then
           mount_layer = EoHS.mount_default_main_layer(         "Chocobone", anim)
      else mount_layer = EoHS.mount_default_main_layer(variables.mount_type, anim) end
    end
  end
  return assemble_one_frame_impl(variables, main_layer, mount_layer)
end

local add_animation_from_unit_type = function(palettes_and_ranges, animations_added, animation_source, frame_graphics_func, options)
  local new_animation = EoHS.deep_copy(animation_source)
  local function fix_frames(table)
    for i,tag in ipairs(table) do
      if tag[1] == "frame" then
        local frame = tag[2]
        frame.image = EoHS.replace_progressive_images(frame.image, function(s)
          -- Leave it alone if it's invalid
          if EoHS.is_valid_image_base(EoHS.get_image_base(s)) then
            return EoHS.collapse_image_aggregate("image_modded", unit_graphics_aggregate(frame_graphics_func(s, new_animation)))
          end
        end)
        EoHS.record_palettes_and_ranges_used(palettes_and_ranges, frame.image)
      end
      if tag[1] == "if" or tag[1] == "else" then fix_frames(tag[2]) end
    end
  end
  if options.squish_anims and options.squish_anims(new_animation) then
    new_animation[2].start_time = 0
    EoHS.remove_subtags(new_animation[2], "*", function(t,name) return string.match(name, "frame") or (name=="if") or (name=="else") end)
    table.insert(new_animation[2], {"frame",{image=options.default_image_modded, duration=1}})
  else
    fix_frames(new_animation[2])
  end
  -- always higher priority than the original animation
  new_animation[2].base_score = (new_animation[2].base_score or 0) + 1
  --table.insert(new_animation, {"filter",{}})
  if options.animation_fixer_func then options.animation_fixer_func(new_animation) end
  table.insert(animations_added, new_animation)
end

local add_animations_from_unit_type = function(palettes_and_ranges, animations_added, animations_source, frame_graphics_func, options)
  for i,potential_anim_tag in ipairs(animations_source) do
    -- Hack - assume an animation is anything with a frame in it, TODO better
    local function search_for_frames(tag)
      if (tag[1]=="female") or (tag[1]=="variation") then return false end
      if string.match(tag[1], "frame") then return true end
      for i,subtag in ipairs(tag[2]) do if search_for_frames(subtag) then return true end end
      return false
    end
    if search_for_frames(potential_anim_tag) and not (options.filter and not options.filter(potential_anim_tag)) then
      add_animation_from_unit_type(palettes_and_ranges, animations_added, potential_anim_tag, frame_graphics_func, options)
    end
  end
end

local anim_apply_tos = {
  recruit_anim = "recruited",
  standing_anim = "standing,default",
  idle_anim = "idling",
  healing_anim = "healing",
  poison_anim = "poisoned",
  sheath_weapon_anim = "sheath_weapon_movement",
  defend = "defend",
  death = "death",
  -- TODO teleport_anim weirdness
}
EoHS.anim_applies_to = function(anim, apply_to)
  return (string.match(anim[1], "^(.+)_anim") == apply_to) or
        (anim[2].apply_to        and string.match(anim[2].apply_to       , apply_to)) or
        (anim_apply_tos[anim[1]] and string.match(anim_apply_tos[anim[1]], apply_to))
end
local get_last_frame = function(anim)
  -- TODO: this is probably wrong
  local last_frame = anim[#anim]
  local function seek_frames(t) for i,t2 in ipairs(t) do if t2[1] == "frame" then last_frame = t2[2] end; seek_frames(t2[2]) end end
  seek_frames(anim)
  return last_frame
end

EoHS.unit_image_stuff = function(unit, image)
  local graphics = assemble_one_frame(EoHS.force_unit_variables(unit), image)
  return EoHS.collapse_image_aggregate("image_modded", unit_graphics_aggregate(graphics)), EoHS.image_layer_offset(graphics.main_layer), EoHS.weapon_head_offset(graphics)
end
EoHS.unit_default_image_stuff = function(unit)
  return EoHS.unit_image_stuff(unit, unit.image)
end
EoHS.unit_casting_image_stuff = function(unit, frame_number)
  return EoHS.unit_image_stuff(unit, EoHS.wizard_casting_image_base(unit, frame_number))
end

local all_initial_anim_apply_tos_list = {"standing","selected","recruited","levelin","levelout",
  "pre_movement","post_movement","movement","defend","attack","death",
  "victory","pre_teleport","post_teleport","healed","poisoned",}
local all_initial_anim_apply_tos = {}
for i,v in ipairs(all_initial_anim_apply_tos_list) do all_initial_anim_apply_tos[v] = true end

local force_duration = function(anim, duration)
  -- TODO forcing shorter durations, handling if/else properly...
  local naive_duration = EoHS.naive_anim_duration(anim)
  if naive_duration < duration then
    local last_frame = get_last_frame(anim)
    EoHS.assert(last_frame, "animation with no frames...?")
    last_frame.duration = (last_frame.duration or 0) + duration - naive_duration
  end
end
EoHS.fill_initial_animations = function(anims, default_image_modded, die_sound, requested_apply_tos)
  -- TODO: What are "ghosted" and "disabled_ghosted"? And "_disabled_" and "_disabled_selected_"?
  local default_anims_needed = {}
  for apply_to in pairs(requested_apply_tos) do default_anims_needed[apply_to] = true end
        
  for apply_to in pairs(default_anims_needed) do
    for i,anim in ipairs(anims) do
      if EoHS.anim_applies_to(anim, apply_to) and (anim[2].terrain == nil) and (anim[2].direction == nil) and (anim[2].terrain_type == nil) and
          (anim[2].value == nil) and (anim[2].value_second == nil) and (anim[2].swing == nil) and (anim[2].frequency == nil) and
          (helper.get_child(anim[2], "filter") == nil) and (helper.get_child(anim[2], "filter_second") == nil) and
          (helper.get_child(anim[2], "filter_attack") == nil) and (helper.get_child(anim[2], "filter_second_attack") == nil) then
        default_anims_needed[apply_to] = nil
        break
      end
    end
  end
  local default_anims = {}
  for i,anim in ipairs(anims) do
    if EoHS.anim_applies_to(anim, "default") then table.insert(default_anims, anim[2]) end
  end

  if not default_anims[1] then default_anims[1] = { start_time=0, {"frame",{duration=1, image=default_image_modded }} } end

  local default_anim_adjust_funcs = {
          standing=function(anim) anim.cycles = true; anim.offscreen = false end,
          selected=function(anim) anim.start_time=0; force_duration(anim, 300); anim.blend_ratio="0.0~0.3:100,0.3~0.0:200"; anim.blend_color="255,255,255" end,
         recruited=function(anim) anim.start_time=0; force_duration(anim, 600); anim.alpha="0~1:600" end,
           levelin=function(anim) anim.start_time=0; force_duration(anim, 600); anim.blend_ratio="1~0:600"; anim.blend_color="255,255,255" end,
          levelout=function(anim) anim.start_time=0; force_duration(anim, 600); anim.blend_ratio="0~1:600"; anim.blend_color="255,255,255" end,
      pre_movement=function(anim) anim.start_time=0 end,
     post_movement=function(anim) anim.start_time=0 end,
          movement=function(anim) anim.start_time=0; force_duration(anim, 6800); anim.offset="0~1:200,0~1:200,0~1:200,0~1:200,0~1:200,0~1:200,0~1:200,0~1:200,0~1:200,0~1:200" end,
            defend=function(anim) anim.start_time=0; anim.hits="hit,kill"; anim.blend_ratio="0.0,0.5:75,0.0:75,0.5:75,0.0"; anim.blend_color="255,0,0" end,
            attack=function(anim) anim.start_time=-150; force_duration(anim, 150); anim.range="ranged"; end,
           attack2=function(anim) anim.start_time=-150; force_duration(anim, 300); anim.range="melee"; anim.offset="0~0.6:150,0.6~0:150" end,
             death=function(anim) anim.start_time=0; force_duration(anim, 600); anim.alpha="1~0:600"; table.insert(anim, {"_death_sound_frame",{ sound=die_sound }}) end,
           victory=function(anim) end,
      pre_teleport=function(anim) anim.start_time=0; force_duration(anim, 150); anim.alpha="1~0:150" end,
     post_teleport=function(anim) anim.start_time=0; force_duration(anim, 150); anim.alpha="0~1:150,1" end,
            healed=function(anim) anim.start_time=0; force_duration(anim, 300); anim.blend_ratio="0:30,0.5:30,0:30,0.5:30,0:30,0.5:30,0:30,0.5:30,0:30"; anim.blend_color="255,255,255"
                                    table.insert(anim, {"_healed_sound",{ sound="heal.wav" }}) end,
          poisoned=function(anim) anim.start_time=0; force_duration(anim, 300); anim.blend_ratio="0:30,0.5:30,0:30,0.5:30,0:30,0.5:30,0:30,0.5:30,0:30"; anim.blend_color="0,255,0"
                                    table.insert(anim, {"_poison_sound",{ sound="poison.ogg" }}) end,
  }
  for i,apply_to in ipairs(all_initial_anim_apply_tos_list) do if default_anims_needed[apply_to] then
    for i,default_anim in ipairs(default_anims) do
      local new_anim = EoHS.deep_copy(default_anim)
      new_anim.apply_to = apply_to
      new_anim.base_score = -5 -- should override all true default anims (-9) but not anything else
      if apply_to == "defend" then table.insert(anims, {"animation",EoHS.deep_copy(new_anim)}) end
      if apply_to == "attack" then local attack2 = EoHS.deep_copy(new_anim); default_anim_adjust_funcs.attack2(attack2); table.insert(anims, {"animation",attack2}) end
      default_anim_adjust_funcs[apply_to](new_anim)
      table.insert(anims, {"animation",new_anim})
    end
  end end
end

local EoHS_changes_base_unit_graphics = EoHS.caching_func(function(variables)
  local unit_attribute_memory = EoHS.get_fake_subtag(variables, "unit_attribute_memory")
  local default_image_aggregate = EoHS.image_aggregate_simplified(unit_graphics_aggregate(assemble_one_frame(variables, unit_attribute_memory.image)))
    
  local untouched_default_image = unit_attribute_memory.image..variables.image_mods
  return default_image_aggregate ~= untouched_default_image
end)

local unit_permanent_animations = EoHS.caching_func(function(variables, requested_apply_tos)
  local unit_attribute_memory = EoHS.get_fake_subtag(variables, "unit_attribute_memory")
  local type_cfg = EoHS.unit_type_considering_variations(unit_attribute_memory)
  local normal_animations = { apply_to = "new_animation" }
  local palettes_and_ranges = {}
  
  local default_graphics = assemble_one_frame(variables, unit_attribute_memory.image)
  local default_image_aggregate = EoHS.image_aggregate_simplified(unit_graphics_aggregate(default_graphics))
  local default_image_modded = EoHS.collapse_image_aggregate("image_modded", default_image_aggregate)
  
  local  unit_frame_graphics_func = function(      layer, anim) return assemble_one_frame(variables, layer,         nil, anim) end
  local mount_frame_graphics_func = function(mount_layer, anim) return assemble_one_frame(variables,   nil, mount_layer, anim) end

  add_animations_from_unit_type(palettes_and_ranges, normal_animations, type_cfg,
    unit_frame_graphics_func, { default_image_modded = default_image_modded,
      squish_anims = function(anim)
        return variables.is_crypt or (variables.is_wizard and EoHS.anim_applies_to(anim, "idling"))
      end
    })

  if variables.is_mounted or is_chocobone_knight(variables) then
    add_animations_from_unit_type(palettes_and_ranges, normal_animations,
      EoHS.unit_type_with_gender_and_variation(is_chocobone_knight(variables) and "Chocobone" or variables.mount_type, variables.mount_gender, variables.mount_variation),
      mount_frame_graphics_func,
      { animation_fixer_func = function(animation)
        if EoHS.anim_applies_to(animation, "attack") then
          EoHS.restrict_contained_filter(animation[2], "filter_attack",        is_chocobone_knight(variables) and { name = "spear" } or { special = "granted_by_mount" })
        end
        if EoHS.anim_applies_to(animation, "defend") then
          EoHS.restrict_contained_filter(animation[2], "filter_second_attack", is_chocobone_knight(variables) and { name = "spear" } or { special = "granted_by_mount" })
        end
      end }
    )
  end
  
  if variables.is_crypt then
    local anim = {}
    for i=1,22 do table.insert(anim, {"frame",{duration=140, auto_hflip=false, image=string.format("scenery/mausoleum%.2d.png", i)}}) end
    table.insert(normal_animations, { "standing_anim", anim })
  end
    
  if EoHS_changes_base_unit_graphics(variables) then
    requested_apply_tos = all_initial_anim_apply_tos
  end
  EoHS.fill_initial_animations(normal_animations, default_image_modded, type_cfg.die_sound, requested_apply_tos)
  
  if variables.is_wizard and not variables.spiritform then -- because you can't cast in spirit form
    local casting_graphics = {
      assemble_one_frame(variables, EoHS.wizard_casting_image_base(unit_attribute_memory, 1)),
      assemble_one_frame(variables, EoHS.wizard_casting_image_base(unit_attribute_memory, 2)), }
    local casting_image_modded = {
      EoHS.collapse_image_aggregate("image_modded", unit_graphics_aggregate(casting_graphics[1])),
      EoHS.collapse_image_aggregate("image_modded", unit_graphics_aggregate(casting_graphics[2])), }
    local default_frame_func = function(contents) contents.image=default_image_modded             ;                  return contents end
    local casting_frame_func = function(contents) contents.image=casting_image_modded[contents[1]]; contents[1]=nil; return contents end
    table.insert(normal_animations, { "animation", { apply_to = "EoHS_start_casting",
      { "frame", default_frame_func{ duration = 200 } },
      { "frame", casting_frame_func{ 1, duration = 200 } },
      { "frame", casting_frame_func{ 2, duration = 200 } },
    }})
    table.insert(normal_animations, { "animation", { apply_to = "EoHS_stop_casting",
      { "frame", casting_frame_func{ 2, duration = 200 } },
      { "frame", casting_frame_func{ 1, duration = 200 } },
      { "frame", default_frame_func{ duration = 200 } },
    }})
    table.insert(normal_animations, { "standing_anim", {
      start_time = -50, 
      { "filter", { EoHS.has_unit_variable("is_casting_a_spell") }},
      { "frame", { duration = 50, image=casting_image_modded[2] } },
    }})
    EoHS.make_wizard_attack_animations(normal_animations,
      EoHS.image_layer_offset(default_graphics.main_layer), EoHS.weapon_head_offset(casting_graphics[2]),
      default_frame_func, casting_frame_func)
  end
  if variables.is_summon and (unit_attribute_memory.type == "Fire Dragon") then
    table.insert(normal_animations, EoHS.dragon_attack_anim(default_image_modded, EoHS.get_fake_subtag(variables, "dragon")))
  end
  
  return normal_animations, palettes_and_ranges, requested_apply_tos
end)

local unit_animation_adjustments = EoHS.caching_func(function(variables)
  local unit_attribute_memory = EoHS.get_fake_subtag(variables, "unit_attribute_memory")
  local status_memory = EoHS.get_fake_subtag(unit_attribute_memory, "status")
  local func_list = {}
  
  local requires_apply_tos = {}
  local poisoned = status_memory.poisoned
  local slowed   = status_memory.slowed
  table.insert(func_list, function(anim)
    local tints = 0
    local r,g,b = 0,0,0
    if poisoned then
      tints = tints + 1
      g = g + 255
    end
    if slowed then
      tints = tints + 1
      r = r + 191
      g = g + 191
      b = b + 255
    end
    if tints > 0 then
      -- TODO: is this the proper interaction with other blends? (overwriting, that is)
      anim[2].blend_ratio = 0.25
      anim[2].blend_color = math.floor(r/tints)..","..math.floor(g/tints)..","..math.floor(b/tints)
    end
    
    local function tweak_frames(block)
      for i,subtag in ipairs(block) do
        if subtag[1] == "frame" then
          -- Always need to unset these, because otherwise all frames will be overridden by the image_mod.
          subtag[2].primary = false
          subtag[2].auto_vflip = false
        end
        tweak_frames(subtag[2])
      end
    end
    tweak_frames(anim[2])
    
    if anim[1] == "defend" then
      -- [defend] automatically adds a red-flash frame, and the unit image mods show up in it.
      -- I haven't found a way to make it base that on otherwise-modded images, so bypass it...
      anim[1] = "animation"
      anim[2].apply_to = "defend"
      local last_frame = EoHS.deep_copy(get_last_frame(anim[2]))
      last_frame.duration = 225
      last_frame.blend_ratio = "0.0,0.5:75,0.0:75,0.5:75,0.0"
      last_frame.blend_color = "255,0,0"
      table.insert(anim[2], {"if",{
        hits="hit,kill",
        {"frame",last_frame}
      }})
    end
  end)
  
  --[[ This didn't work. Looks like there's no layer high enough to go above the default orb
  if variables.is_wizard then
    requires_apply_tos.standing = true
    table.insert(func_list, function(anim, add_anim)
      if EoHS.anim_applies_to(anim, "standing") then
        local new_anim = EoHS.deep_copy(anim)
        table.insert(new_anim[2], {"filter",{ {"filter_wml",{ attacks_left=0 }} }})
        table.insert(new_anim[2], {"orb_squisher_frame",{
          image="misc/orb-unmoved.png~CS(-255,-255,-255)~CS(0,200,200)~O(0.5)",
          auto_vflip=false, auto_hflip=false,
          layer=100,
          duration=1000,
        }})
        add_anim(new_anim)
      end
    end)
  end]]
  
  if variables.haste_turns then
    requires_apply_tos = all_initial_anim_apply_tos
    table.insert(func_list, function(anim)
      -- Super hacky haste graphics
      -- Some duplicate code with the siphon strength graphics
      if EoHS.anim_applies_to(anim, "standing") or EoHS.anim_applies_to(anim, "movement") then
        -- TODO make separate names for {"animation", foo} and just foo
        local duration = EoHS.naive_anim_duration(anim[2])
        EoHS.assert(duration ~= 0, "Animation with 0 duration, what? "..EoHS.inspect(anim))
        anim[2].x = string.gsub(string.rep("0~2,2~0,0~-2,-2~0,", math.ceil(duration / 300)), ",$", "") -- TODO don't mess with preexisting x=
        local function tweak_frames(block)
          for i,subtag in ipairs(block) do
            if subtag[1] == "frame" then
              if subtag[2].duration and (duration < 340) then subtag[2].duration = subtag[2].duration * 340 / duration end
              subtag[2].image = EoHS.replace_progressive_images(subtag[2].image, function(image, dur)
                return haste_modded(image), (dur and (duration < 340) and (dur * 340 / duration)) end)
              --local duration = EoHS.frame_duration(subtag[2])
              --if duration < 170 then duration = 170; subtag[2].duration = 170 end
              --subtag[2].x = string.gsub(string.rep("0~3,3~0,0~-3,-3~0,", math.floor(duration / 150)), ",$", "") -- TODO don't mess with preexisting x=
            end
            tweak_frames(subtag[2])
          end
        end
        tweak_frames(anim[2])
      end
    end)
  end
  
  local add_circling_image = function(anim, id, params)
    anim["EoHS_"..id.."_front_cycles"] = true
    anim["EoHS_"..id.. "_back_cycles"] = true
    anim["EoHS_"..id.."_front_start_time"] = 0
    anim["EoHS_"..id.. "_back_start_time"] = 0
    local xtab,ytab,atab={},{},{}
    local num = 30
    for i=0,num-1 do
      local input = ((params.starting_point or 0) + (i/num))*2*math.pi
      xtab[i] = math.floor(0.5+params.x(input))
      ytab[i] = math.floor(0.5+params.y(input))
      atab[i] = math.max(0, math.min(1, (params.z(input)+1)/2))
    end
    local xtab2,ytab2,afronttab,abacktab={},{},{},{}
    for i=0,num-1 do
      xtab2[i+1] = string.format("%.3f~%.3f", xtab[i], xtab[(i+1)%num])
      ytab2[i+1] = string.format("%.3f~%.3f", ytab[i], ytab[(i+1)%num])
      afronttab[i+1] = string.format("%.3f~%.3f", ((params.frame.alpha or 1) * atab[i]), ((params.frame.alpha or 1) * atab[(i+1)%num]))
      abacktab[i+1] = string.format("%.3f~%.3f", ((params.frame.alpha or 1) * (1-atab[i])), ((params.frame.alpha or 1) * (1-atab[(i+1)%num])))
    end
    local x,y,afront,aback = table.concat(xtab2,","),table.concat(ytab2,","),table.concat(afronttab,","),table.concat(abacktab,",")
    -- A front-layer copy and a back-layer copy.
    -- Making layer= progressive is OK, but it makes the image snap across the plane of the wizard,
    -- when fading across is nicer.
    local front = EoHS.deep_copy(params.frame)
    front.auto_vflip = false
    front.x=x
    front.y=y
    front.layer=70
    front.alpha=afront
    local back = EoHS.deep_copy(front)
    back.layer = 35
    back.alpha = aback
    table.insert(anim, {"EoHS_"..id.."_front_frame",front})
    table.insert(anim, {"EoHS_"..id.. "_back_frame", back})
  end
  
  if variables.ritual then
    requires_apply_tos.standing = true
    local ritual    = variables.ritual
    local runes     = variables.ritual_runes
    local runes_lit = variables.ritual_runes_lit
    local parameters= EoHS.get_fake_subtag(variables, "ritual_parameters")
    local ax,ay,tx,ty
    local action = EoHS.actions[ritual]
    if action.is_summon then ax,ay,tx,ty = unit_attribute_memory.x, unit_attribute_memory.y, parameters.target_x, parameters.target_y end
    table.insert(func_list, function(anim)
      if EoHS.anim_applies_to(anim, "standing") or EoHS.anim_applies_to(anim, "selected") then
        for i=1,runes do
          add_circling_image(anim[2], "ritual_rune_"..i, {
            frame = { image = "scenery/rune"..i..((runes_lit>=i) and "-glow" or "")..".png~SCALE(48,48)", auto_hflip=false, duration = 6400 },
            starting_point = i / runes,
            x = function(a) return -30*math.cos(a) end,
            y = function(a) return 14*math.sin(a) end,
            z = function(a) return 2*math.sin(a) end,
          })
        end
        if action.is_summon then
          local dx,dy = EoHS.pixels_to_hex(ax,ay,tx,ty)
          local min_alpha,max_alpha = (runes_lit-0.7)/runes/2, (runes_lit+0.7)/runes/2
          anim[2].EoHS_summon_cycles = true
          table.insert(anim[2], {"EoHS_summon_frame",{
            image = action.summon_prototype_image.."~GS()",
            alpha = string.format("%.3f~%.3f,%.3f~%.3f", min_alpha, max_alpha, max_alpha, min_alpha),
            x=dx,y=dy,auto_hflip=false,auto_vflip=false,
            duration = 5000,
          }})
        end
      end
    end)
  end
  
  if variables.strength_siphoner_id then
    requires_apply_tos.standing = true
    local x1 = unit_attribute_memory.x
    local y1 = unit_attribute_memory.y
    local x2 = variables.strength_siphoner_x
    local y2 = variables.strength_siphoner_y
    local dx, dy = EoHS.pixels_to_hex(x1,y1,x2,y2)
    local dist = EoHS.distance_between(x1,y1,x2,y2)
    table.insert(func_list, function(anim)
      if EoHS.anim_applies_to(anim, "standing") then
        for i=1,dist do
          anim[2]["EoHS_siphon_strength_"..i.."_cycles"] = true
          local remaining_dur = 2000
          if i == 1 then remaining_dur = remaining_dur - 300 end
          if i == dist then remaining_dur = remaining_dur - 300 end
          local alphas = {}
          if i == 1 then table.insert(alphas, "0~1:300") end
          table.insert(alphas, "1:"..remaining_dur)
          if i == dist then table.insert(alphas, "1~0:300") end
          table.insert(anim[2], {"EoHS_siphon_strength_"..i.."_frame",{
            image="projectiles/wailprojectile-n-3.png",
            auto_vflip=false, auto_hflip=false,
            x=(dx*(i-1)/dist).."~"..(dx*i/dist), y=(dy*(i-1)/dist).."~"..(dy*i/dist),
            layer=70,
            alpha=table.concat(alphas, ","),
            duration=2000,
          }})
        end
      end
    end)
  end
  
  if variables.soul_bind_images then
    requires_apply_tos.standing = true
    local images = variables.soul_bind_images
    table.insert(func_list, function(anim)
      if EoHS.anim_applies_to(anim, "standing") then
        local i = 1
        for image in string.gmatch(images, "BeginSoulImage(.-)EndSoulImage") do
          -- Hack - pseudorandom cycle duration from string length
          local duration = 3000+(string.len(image)%12)*300
          local starting_point = (string.len(image)%math.ceil(duration/500)) / math.ceil(duration/500)
          add_circling_image(anim[2], "bound_soul_"..i, {
            frame = {
              image = image,
              duration = duration,
              blend_color = "0,0,0",
              blend_ratio = 1,
              alpha = 0.15,
            },
            starting_point = starting_point,
            x = function(a) return -20*math.cos(a) end,
            y = function(a) return 6*math.sin(a) end,
            z = function(a) return 2*math.sin(a) end,
          })
          i = i + 1
        end
      end
    end)
  end
  
  local requires_hit = function(hits)
    return hits and ((hits == true) or ((type(hits) == "string") and (string.match(hits, "hit") or string.match(hits, "yes"))))
  end
  local requires_miss = function(hits)
    return hits and ((hits == false) or ((type(hits) == "string") and (string.match(hits, "miss") or string.match(hits, "no"))))
  end
  local function replace_hits(filtering_block, fname)
    if requires_hit(filtering_block.hits) then
      EoHS.restrict_contained_filter(filtering_block, fname, {EoHS.has_unit_variable("mage_shield_gets_hit_next_swing")})
      filtering_block.hits = "miss"
    end
    if requires_miss(filtering_block.hits) then
      EoHS.restrict_contained_filter(filtering_block, fname, {{"not",{EoHS.has_unit_variable("mage_shield_gets_hit_next_swing")}}})
      filtering_block.hits = "miss"
    end
    for i,subtag in ipairs(filtering_block) do
      if (subtag[1] == "if") or (subtag[1] == "else") then
        replace_hits(subtag[2], fname)
      end
    end
  end
  -- TODO fix elusive mage shield graphics glitches
  if variables.attacking_a_mage_shield then
    requires_apply_tos.attack = true
    table.insert(func_list, function(anim, add_anim)
      if EoHS.anim_applies_to(anim, "attack") then
        local new_anim = EoHS.deep_copy(anim)
        new_anim[2].base_score = (new_anim[2].base_score or 0) + 1
        EoHS.restrict_contained_filter(new_anim[2], "filter_second", {{"not",{EoHS.has_unit_variable("mage_shields_active_0")}}})
        replace_hits(new_anim[2], "filter_second")
        add_anim(new_anim)
      end
    end)
  end
  if variables.using_a_mage_shield and variables.mage_shields then
    requires_apply_tos.attack = true
    requires_apply_tos.defend = true
    requires_apply_tos.death = true
    local shields = variables.mage_shields
    table.insert(func_list, function(normal_anim, add_anim)
      for shields_left=0,math.min(10, shields) do -- capping just in case
        local opacity = ((shields_left+1)/3)
        if shields_left == 0 then opacity = 0 end
        if EoHS.anim_applies_to(normal_anim, "defend") or ((shields_left < shields) and
            (EoHS.anim_applies_to(normal_anim, "attack") or EoHS.anim_applies_to(normal_anim, "death"))) then
          local anim = EoHS.deep_copy(normal_anim)
          anim[2].base_score = (anim[2].base_score or 0) + 1
          EoHS.restrict_contained_filter(anim[2], "filter", {EoHS.has_unit_variable("mage_shields_active_"..shields_left)})
          
          if EoHS.anim_applies_to(anim, "defend") then
            if shields_left > 0 then
              replace_hits(anim[2], "filter")
              anim[2].EoHS_shield_break_start_time = 0
              table.insert(anim[2], {"if",{
                {"filter",{EoHS.has_unit_variable("mage_shield_gets_hit_next_swing")}},
                {"EoHS_shield_break_frame",{
                  start=0, duration=1, -- none of this worked. TODO is there a way to draw the text at the right time?
                  text=_"blocked",
                  text_color="128,128,255",
                }}
              }})
            end
          end
          local function tweak_frames(block)
            for i,subtag in ipairs(block) do
              if subtag[1] == "frame" then
                subtag[2].image = EoHS.replace_progressive_images(subtag[2].image, function(img)
                  return (string.gsub(img, EoHS.lua_pattern_escape("halo/elven/elven-shield-halo-100pct.png~O(").."(.-)%)", function(s)
                                                            return "halo/elven/elven-shield-halo-100pct.png~O("..opacity..")" end))
                end)
              end
              tweak_frames(subtag[2])
            end
          end
          tweak_frames(anim[2])
          add_anim(anim)
        end
      end
    end)
  end
  
  variables = nil --(to make sure the returned functions don't access it directly, which would be a bug)
  return requires_apply_tos, function(anim, add_anim)
    for i,func in ipairs(func_list) do func(anim, add_anim) end
  end
end)
EoHS.unit_animation_adjustments = function(unit)
  local r, func = unit_animation_adjustments(EoHS.force_unit_variables(unit))
  return func
end

local unit_permanent_graphics_object = EoHS.caching_func(function(variables)
  local effects = {id = "EoHS_permanent_graphics_stuff"}
  
  local adjuster_requested_apply_tos, animation_adjustment_func = unit_animation_adjustments(variables)
  local normal_animations, palettes_and_ranges, requested_apply_tos = unit_permanent_animations(variables, adjuster_requested_apply_tos)
  
  if next(requested_apply_tos) then
    normal_animations = EoHS.deep_copy(normal_animations)
    local add_anim = function(anim)
      table.insert(normal_animations, anim)
    end
    local old_len = #normal_animations
    for i=1,old_len do
      animation_adjustment_func(normal_animations[i], add_anim)
    end
  end
    
  if palettes_and_ranges[1] then table.insert(effects, EoHS.palettes_and_ranges_effect(palettes_and_ranges)) end
  if normal_animations[1] then table.insert(effects, { "effect", normal_animations }) end
  --if variables.using_a_mage_shield then EoHS.debug(normal_animations) end
  
  if EoHS_changes_base_unit_graphics(variables) then
    local unit_attribute_memory = EoHS.get_fake_subtag(variables, "unit_attribute_memory")
    local default_graphics = assemble_one_frame(variables, unit_attribute_memory.image)
    local sidebar_image_aggregate = EoHS.image_aggregate_simplified(unit_graphics_aggregate(default_graphics))
    local extents = EoHS.image_aggregate_extents(sidebar_image_aggregate)
    if (extents.size.x > 72) or (extents.size.y > 72) then
      sidebar_image_aggregate = EoHS.image_aggregate_cropped(
        EoHS.image_aggregate_translated(sidebar_image_aggregate,
          EoHS.offset_negated(EoHS.image_layer_offset(default_graphics.main_layer))), { size={x=72,y=72}, offset={x=0,y=0} })
    end
    local image_mod_effect_contents = {
      apply_to = "image_mod",
      replace = EoHS.collapse_image_aggregate("override_mod", sidebar_image_aggregate).."~R(1)~R(-1)~BG(0,0,0)", -- BG it so that it shows up in the right place in the sidebar; R+1-1 because BG doesn't work without it for some reason (TODO investigate)
    }
    -- To make the advance dialog not have its pictures overridden...
    -- (Darn. It doesn't work. But I might still prefer to have EoHS graphics fail rather than regular graphics fail when some non-EoHS code changes type.)
    -- (TODO, consider putting filters like this on the other animation effects, adding gender and variation to the filter...?)
    if w111 then
      table.insert(image_mod_effect_contents, {"filter",{type=unit_attribute_memory.type}})
    else
      image_mod_effect_contents.unit_type = unit_attribute_memory.type
    end
    table.insert(effects, { "effect", image_mod_effect_contents })
  end
  
  return { "object", effects }
end)

local update_unit_permanent_graphics_object = function(unit)
  local object, was_valid = unit_permanent_graphics_object(EoHS.force_unit_variables(unit))
  if not was_valid then
    local modifications = EoHS.get_subtag(unit, "modifications")
    EoHS.remove_subtags(modifications, "object", "EoHS_permanent_graphics_stuff")
    if not modifications then
      modifications = {}
      table.insert(unit, { "modifications", modifications })
    end
    table.insert(modifications, object)
    return true
  end
  return false
end

local unit_thumbnail = EoHS.caching_func(function(variables, more_like_builtin)
  local unit_attribute_memory = EoHS.get_fake_subtag(variables, "unit_attribute_memory")
  
  --hack - save me from segfaults. TODO hunt this segfault some more
  local image = unit_attribute_memory.image
  if image == "units/monsters/fire-dragon.png" then image = "units/drakes/armageddon.png" end
  if w111 and (image == "units/monsters/skeletal-dragon/skeletal-dragon.png") then image = "units/drakes/armageddon.png~GS()" end
    
  local default_graphics = assemble_one_frame(variables, image)
  local add_ellipse = function(image_aggregate)
    return EoHS.image_aggregates_combined(
      variables.ellipse.."top.png"   ..EoHS.TC_image_mod(unit_attribute_memory.side, "ellipse_red"),
      image_aggregate,
      variables.ellipse.."bottom.png"..EoHS.TC_image_mod(unit_attribute_memory.side, "ellipse_red"))
  end
  local result = EoHS.image_aggregate_translated(unit_graphics_aggregate(default_graphics),
                   EoHS.offset_negated(EoHS.image_layer_offset(default_graphics.main_layer)))
  if not more_like_builtin then result = add_ellipse(result) end
  local dim = more_like_builtin and 72 or 58
  return EoHS.collapse_image_aggregate("image_modded",
    EoHS.image_aggregate_cropped(result, { size={x=dim,y=dim}, offset={x=0,y=0} })
  )
end)

local update_unit_graphics_variables = function(unit)
  local variables = EoHS.force_unit_variables(unit)
  local unit_attribute_memory = EoHS.get_fake_subtag(variables, "unit_attribute_memory")
  EoHS.assert(unit_attribute_memory.type == unit.type, "Unit type should be up-to-date before calling EoHS.update_unit_graphics_variables (try EoHS.standardize_unit)")
  EoHS.assert(unit_attribute_memory.side == unit.side, "Unit side should be up-to-date before calling EoHS.update_unit_graphics_variables (try EoHS.standardize_unit)")
  
  -- Looking through the effects is outside the caching functions because we don't store the effects in variables in the same way.
  local ellipse = EoHS.get_unit_type(unit_attribute_memory.type).ellipse or "misc/ellipse"
  local image_mods = ""
  for i,effect in ipairs(EoHS.get_unit_effects(unit, {exclude_id = "EoHS_permanent_graphics_stuff"})) do
    if effect.apply_to == "ellipse" then ellipse = effect.ellipse end
    if effect.apply_to == "image_mod" then
      if effect.replace then
        -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.7) uses "RC()" when it should use "~RC()"
        if string.sub(effect.replace, 1, 1) ~= "~" then effect.replace = "~"..effect.replace end
        image_mods = effect.replace
      end
      if effect.add then
        -- Hack to appease the macro TEAM_COLOR_OVERRIDE, which currently (1.10.7) uses "RC()" when it should use "~RC()"
        if string.sub(effect.add, 1, 1) ~= "~" then effect.add = "~"..effect.add end
        image_mods = image_mods..effect.add
      end
    end
  end
  image_mods = image_mods..EoHS.unit_TC_image_mod(unit_attribute_memory)
  variables.image_mods = image_mods
  variables.ellipse = ellipse.."-"..(w111 and unit.canrecruit and "leader-" or "")..(w111 and (not unit.zoc) and "nozoc-" or "")
  
  if variables.strength_siphoner_id then
    local siphoner = EoHS.get_unit(variables.strength_siphoner_id)
    if siphoner then
      variables.strength_siphoner_x = siphoner.x
      variables.strength_siphoner_y = siphoner.y
    end
  end
end

EoHS.unit_thumbnail = function(unit, more_like_builtin)
  local variables = EoHS.force_unit_variables(unit)
  --if not variables.id then EoHS.standardize_unit(unit) end -- hack... TODO more thinking about where standardization should occur
  if not variables.ellipse then update_unit_graphics_variables(unit) end
  return unit_thumbnail(variables, more_like_builtin)
end

EoHS.update_unit_graphics = function(unit)
  update_unit_graphics_variables(unit)
  return update_unit_permanent_graphics_object(unit)
end

-- TODO: special (their ordinary) fireball anim for troll shamans, maybe 
EoHS.make_wizard_attack_animations = function(animations, wizard_offset, casting_frame_2_weapon_offset, default_frame_func, casting_frame_func)
  local fireball_missile_frame = function(number, duration, min, max)
    return { "missile_frame", {
      offset = ""..min.."~"..max, duration = duration,
      directional_x = ""..math.floor(wizard_offset.x*(1-min)).."~"..math.floor(wizard_offset.x*(1-max)),
      y = ""..math.floor(wizard_offset.y*(1-min)).."~"..math.floor(wizard_offset.y*(1-max)),
      image = "projectiles/fireball-n"..number..".png", image_diagonal = "projectiles/fireball-nw"..number..".png",
    }}
  end
  local fireball_impact_frame = function(number)
    return { "missile_frame", {
      offset = "1.0", duration = 60,
      halo = "projectiles/fireball-impact-"..number..".png",
      auto_vflip = false,
    }}
  end
  local fireball_fail_frame = function(number)
    return { "missile_frame", {
      duration = 100,
      image = "projectiles/fireball-fail-"..number..".png",
      auto_vflip = false,
    }}
  end
  table.insert(animations, { "attack_anim", { start_time = -575, 
    { "filter_attack", { name = "EoHS_evocation_skill_ranged_attack", }},
    
    start_time = -575,
    { "frame", default_frame_func{    duration =  50,                    } },
    { "frame", casting_frame_func{ 1, duration = 100, sound = "fire.wav" } },
    { "frame", casting_frame_func{ 2, duration = 150,                    } },
    { "frame", casting_frame_func{ 1, duration =  75,                    } },
    { "frame", default_frame_func{    duration =  75,                    } },

    missile_start_time = -350,
    { "if", { hits = "yes",
      fireball_missile_frame("-1", 40, 0.0, 0.1),
      fireball_missile_frame("-2", 100, 0.1, 0.3),
      fireball_missile_frame("", 125, 0.3, 0.6),
      fireball_missile_frame("-2", 55, 0.7, 0.8),
      fireball_missile_frame("-1", 30, 0.8, 0.9),
      fireball_impact_frame(1),
      fireball_impact_frame(2),
      fireball_impact_frame(3),
      fireball_impact_frame(4),
      fireball_impact_frame(5),
      fireball_impact_frame(6),
      fireball_impact_frame(7),
      fireball_impact_frame(8),
      fireball_impact_frame(9),
      fireball_impact_frame(10),
      fireball_impact_frame(11),
      fireball_impact_frame(12),
      fireball_impact_frame(13),
      fireball_impact_frame(14),
      fireball_impact_frame(15),
      fireball_impact_frame(16),
    }},
    { "else", { hits = "no",
      missile_offset = "0.0~0.20,0.20~0.35,0.35~0.40,0.4~0.45",
      missile_directional_x = ""..(wizard_offset.x*(1-0.0)).."~"..(wizard_offset.x*(1-0.20))..","..(wizard_offset.x*(1-0.20)).."~"..(wizard_offset.x*(1-0.35))..","..(wizard_offset.x*(1-0.35)).."~"..(wizard_offset.x*(1-0.40))..","..(wizard_offset.x*(1-0.4)).."~"..(wizard_offset.x*(1-0.45)),
      missile_y = ""..(wizard_offset.y*(1-0.0)).."~"..(wizard_offset.y*(1-0.20))..","..(wizard_offset.y*(1-0.20)).."~"..(wizard_offset.y*(1-0.35))..","..(wizard_offset.y*(1-0.35)).."~"..(wizard_offset.y*(1-0.40))..","..(wizard_offset.y*(1-0.4)).."~"..(wizard_offset.y*(1-0.45)),
      fireball_fail_frame(1),
      fireball_fail_frame(2),
      fireball_fail_frame(3),
      fireball_fail_frame(4),
      fireball_fail_frame(5),
      fireball_fail_frame(6),
      fireball_fail_frame(7),
    }}
  }})
  
  local faeriefire_frame = function(halo_number, castframe_number)
    return { "frame", casting_frame_func{ castframe_number, duration = 75, halo = "halo/elven/faerie-fire-halo"..halo_number..".png", halo_x = casting_frame_2_weapon_offset.x, halo_y = casting_frame_2_weapon_offset.y }}
  end
  table.insert(animations, { "attack_anim", { start_time = -450,
    { "filter_attack", { name = "EoHS_nature_magic_skill_ranged_attack", }},
    
    start_time = -450,
    faeriefire_frame(1, 1),
    faeriefire_frame(2, 2),
    faeriefire_frame(3, 2),
    faeriefire_frame(4, 2),
    faeriefire_frame(5, 2),
    faeriefire_frame(6, 2),
    faeriefire_frame(7, 1),
    
    sound_start_time = -450,
    { "if", { hits = "yes", { "sound_frame", { duration = 0, sound = "magic-faeriefire.ogg" }} }},
    { "else", { hits = "no", { "sound_frame", { duration = 0, sound = "magic-faeriefire-miss.ogg" }} }},
    
    missile_start_time = -500,
    missile_directional_x = ""..wizard_offset.x.."~0",
    missile_y = ""..wizard_offset.y.."~0",
    missile_halo_start_time = -500,
    missile_halo_layer = 10,
    missile_halo_directional_x = ""..wizard_offset.x.."~0",
    missile_halo_y = ""..wizard_offset.y.."~0",
    missile_halo_offset = "0~1",
    { "missile_frame",      { duration = 150, image = "projectiles/icemissile-n-1.png", image_diagonal = "projectiles/icemissile-ne-1.png", }},
    { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo1.png", }},
    { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo2.png", }},
    { "missile_frame",      { duration = 150, image = "projectiles/icemissile-n-2.png", image_diagonal = "projectiles/icemissile-ne-2.png", }},
    { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo3.png", }},
    { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo4.png", }},
    { "missile_frame",      { duration = 150, image = "projectiles/icemissile-n-3.png", image_diagonal = "projectiles/icemissile-ne-3.png", }},
    { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo5.png", }},
    { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo1.png", }},
    { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo2.png", }},
    { "missile_frame",      { duration =  50, image = "projectiles/icemissile-n-4.png", image_diagonal = "projectiles/icemissile-ne-4.png", }},
    { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo6.png", }},
    { "missile_frame",      { duration =  75, image = "projectiles/icemissile-n-5.png", image_diagonal = "projectiles/icemissile-ne-5.png", }},
    { "missile_halo_frame", { duration =  75, image = "halo/elven/ice-halo7.png", }},
    { "missile_frame",      { duration =  50, image = "projectiles/icemissile-n-6.png", image_diagonal = "projectiles/icemissile-ne-6.png", }},
    { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo8.png", }},
    { "missile_frame",      { duration =  50, image = "projectiles/icemissile-n-7.png", image_diagonal = "projectiles/icemissile-ne-7.png", }},
    { "missile_halo_frame", { duration =  50, image = "halo/elven/ice-halo9.png", }},
  }})

  local necro_halo_y = math.floor((wizard_offset.y + casting_frame_2_weapon_offset.y) / 2) + 11
  table.insert(animations, { "attack_anim", { start_time = -300,
    { "filter_attack", { name = "EoHS_necromancy_skill_ranged_attack", }},
    
    start_time = -300,
    { "frame", casting_frame_func{ 1, duration = 75 } },
    { "frame", casting_frame_func{ 2, duration = 75 } },
    { "frame", casting_frame_func{ 2, duration = 75, halo = "halo/undead/black-magic-1.png", halo_x = wizard_offset.x, halo_y = necro_halo_y, }},
    { "frame", casting_frame_func{ 2, duration = 75, halo = "halo/undead/black-magic-2.png", halo_x = wizard_offset.x, halo_y = necro_halo_y, }},
    { "frame", casting_frame_func{ 2, duration = 75, halo = "halo/undead/black-magic-3.png", halo_x = wizard_offset.x, halo_y = necro_halo_y, }},
    { "frame", casting_frame_func{ 2, duration = 75, halo = "halo/undead/black-magic-4.png", halo_x = wizard_offset.x, halo_y = necro_halo_y, }},
    { "frame", casting_frame_func{ 2, duration = 50, halo = "halo/undead/black-magic-5.png", halo_x = wizard_offset.x, halo_y = necro_halo_y, }},
    { "frame", casting_frame_func{ 2, duration = 50, }},
    { "frame", casting_frame_func{ 1, duration = 50, }},
    
    sound_start_time = -75,
    { "if", { hits = "yes", { "sound_frame", { duration = 0, sound = "magic-dark.ogg" }} }},
    { "else", { hits = "no", { "sound_frame", { duration = 0, sound = "magic-dark-miss.ogg" }} }},

    missile_start_time = -100,
    missile_directional_x = ""..wizard_offset.x.."~0",
    missile_y = ""..wizard_offset.y.."~0",
    { "missile_frame", {
      duration = 200,
      image = "projectiles/darkmissile-n.png",
      image_diagonal = "projectiles/darkmissile-ne.png",
    }},
  }})
end

-->>)}

